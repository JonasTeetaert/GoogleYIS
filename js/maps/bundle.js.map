{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/js/Layer.js","app/js/Popup.js","app/js/Smooth.js","app/js/data-fr.js","app/js/data-nl.js","app/js/index.js","app/js/main.js","node_modules/animejs/lib/anime.js","node_modules/hammerjs/hammer.js","node_modules/nodelist-foreach-polyfill/index.js"],"names":[],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","class Layer {\n  constructor(layer, cursor, data, popup) {\n    this.layer = layer;\n    this.cursor = cursor;\n    this.data = data;\n    this.popup = popup;\n    this.id = layer.id;\n    this.buttons = layer.querySelectorAll('.button');\n    this.paths = layer.querySelectorAll('path');\n    this.init();\n  }\n\n  init() {\n    const mq = window.matchMedia('(min-width: 801px)');\n    if (mq.matches) {\n      this.paths.forEach(p => {\n        p.addEventListener('mouseenter', (e) => {\n          this.cursor.classList.add('show');\n        })\n        p.addEventListener('mouseleave', (e) => {\n          this.cursor.classList.remove('show');\n        });\n        p.addEventListener('click', this.openPopup.bind(this));\n      });\n    } else {\n      this.buttons.forEach(btn => {\n        btn.addEventListener('click', this.openPopup.bind(this));\n      });\n    }\n  }\n\n  openPopup(e) {\n    const data = this.data.filter(person => person.id === this.id);\n    this.popup.set(data[0]);\n    this.popup.open();\n  }\n}\n\nexport default Layer;","class Popup {\r\n  constructor(node, coverLayer) {\r\n    this.node = node;\r\n    this.name = node.querySelector('.person__name');\r\n    this.rank = node.querySelector('.person__number');\r\n    this.list = node.querySelector('.person__rank');\r\n    this.description = node.querySelector('.popup__description');\r\n    this.imgSmall = node.querySelector('.person__img-container img');\r\n    this.imgBig = node.querySelector('.popup__img');\r\n    this.btnClose = node.querySelector('.popup__close');\r\n    this.status = false;\r\n    this.smooth = null;\r\n\r\n    this.coverLayer = coverLayer;\r\n\r\n    this.btnClose.addEventListener('click', this.close.bind(this));\r\n  }\r\n\r\n  setSmooth(smooth) {\r\n    this.smooth = smooth;\r\n  }\r\n\r\n  open() {\r\n    this.coverLayer.style.pointerEvents = 'none';\r\n    document.body.style.pointerEvents = 'none';\r\n    this.status = true;\r\n    this.node.classList.add('show');\r\n    const mq = window.matchMedia('(min-width: 801px)');\r\n    if (mq.matches) {\r\n      this.smooth.cancelAnimationFrame();\r\n    }\r\n  }\r\n\r\n  close(e) {\r\n    e.preventDefault();\r\n    this.node.classList.remove('show');\r\n    this.coverLayer.style.pointerEvents = 'visible';\r\n    document.body.style.pointerEvents = 'visible';\r\n    this.status = false;\r\n    const mq = window.matchMedia('(min-width: 801px)');\r\n    if (mq.matches) {\r\n      this.smooth.requestAnimationFrame();\r\n    }\r\n  }\r\n\r\n  set(data) {\r\n    this.name.innerHTML = data.name;\r\n    this.rank.innerHTML = data.rank;\r\n    this.list.innerHTML = data.list;\r\n    this.description.innerHTML = data.description;\r\n    this.imgSmall.src = data.imgSmall;\r\n    this.imgBig.src = data.imgBig;\r\n  }\r\n}\r\n\r\nexport default Popup;","import Hammmer from 'hammerjs';\r\nclass Smooth {\r\n  constructor(popup, layerObjects) {\r\n    this.bindMethods()\r\n\r\n    this.data = {\r\n      ease: 0.1,\r\n      current: {\r\n        x: 0,\r\n        y: 0,\r\n      },\r\n      last: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      delta: {\r\n        x: 0,\r\n        y: 0,\r\n      },\r\n      lastPan: {\r\n        x: 0,\r\n        y: 0,\r\n      }\r\n    }\r\n    this.popup = popup;\r\n    this.layerObjects = layerObjects;\r\n\r\n    // mouse\r\n    this.mouse = {\r\n      x: window.innerWidth / 2,\r\n      y: window.innerHeight / 2,\r\n    }\r\n\r\n    this.center = {\r\n      x: window.innerWidth / 2,\r\n      y: window.innerHeight / 2 + 25,\r\n    }\r\n    this.currentEvent = null;\r\n    this.prevEvent = null;\r\n\r\n    this.config = {\r\n      height: window.innerHeight,\r\n      width: window.innerWidth,\r\n      padding: 150,\r\n      offset: 50,\r\n      speed: 10,\r\n    }\r\n\r\n    this.math = {\r\n      lerp: (a, b, n) => {\r\n        return (1 - n) * a + n * b\r\n      },\r\n      norm: (value, min, max) => {\r\n        return (value - min) / (max - min)\r\n      }\r\n    }\r\n\r\n    this.dom = {\r\n      cover: document.querySelector('.cover-layer .smooth-nav'),\r\n      skew: document.querySelector('.skew'),\r\n      cursor: document.querySelector('.cursor'),\r\n      eyes: document.querySelectorAll('.eye'),\r\n    }\r\n\r\n    this.rAF = null\r\n\r\n    this.init();\r\n  }\r\n\r\n  bindMethods() {\r\n    ['run', 'requestAnimationFrame', 'cancelAnimationFrame', 'onPan']\r\n      .forEach((fn) => this[fn] = this[fn].bind(this))\r\n  }\r\n\r\n  handleMouseMove(event) {\r\n    this.currentEvent = event;\r\n    if (event && !this.popup.status) {\r\n      this.mouse = {\r\n        x: event.clientX,\r\n        y: event.clientY,\r\n      }\r\n      this.dom.cursor.style.transform = `translate3d(${this.mouse.x}px, ${this.mouse.y}px, 0)`;\r\n\r\n      this.dom.eyes.forEach((eye, i) => {\r\n        eye.setAttribute('transform', `translate(${this.mouse.x}, ${this.mouse.y}) scale(${1 - (i * 0.08)})`);\r\n      });\r\n\r\n      if (this.currentEvent && this.prevEvent) {\r\n        this.data.current.x -= this.currentEvent.screenX - this.prevEvent.screenX;\r\n        this.data.current.y -= this.currentEvent.screenY - this.prevEvent.screenY;\r\n      }\r\n    }\r\n  }\r\n\r\n  run() {\r\n    // if (this.currentEvent && this.prevEvent) {\r\n    //   this.data.delta.x = this.currentEvent.screenX - this.prevEvent.screenX;\r\n    //   this.data.delta.y = this.currentEvent.screenY - this.prevEvent.screenY;\r\n    // }\r\n    this.prevEvent = this.currentEvent;\r\n\r\n    const diffX = this.data.delta.x;\r\n    const accX = diffX / this.config.width;\r\n    const veloX = +accX;\r\n    const skewX = veloX * 117.5;\r\n\r\n    const diffY = this.data.delta.y;\r\n    const accY = diffY / this.config.height;\r\n    const veloY = +accY;\r\n    const skewY = veloY * 1000;\r\n\r\n    // console.log(skewX, skewY);\r\n    // this.dom.skew.style.transform = `skew(${skewX}deg, ${-skewY}deg)`;\r\n\r\n    // move parent\r\n    this.moveParent();\r\n\r\n    this.requestAnimationFrame();\r\n  }\r\n\r\n  onPan(e) {\r\n    if (e.type === 'panmove') {\r\n      this.data.current.x = this.data.lastPan.x + e.deltaX;\r\n      this.data.current.y = this.data.lastPan.y + e.deltaY;\r\n    }\r\n\r\n    this.layerObjects.forEach(layer => {\r\n      layer.buttons.forEach(btn => {\r\n        const pos = btn.getBoundingClientRect();\r\n        const dist = Math.sqrt(Math.pow(Math.abs(this.center.x - pos.left), 2) + Math.pow(Math.abs(this.center.y - pos.top), 2));\r\n        // const dist = Math.hypot(center.x - pos.left, center.y - center.top);\r\n        if (dist < 120) {\r\n          btn.classList.add('show');\r\n        } else {\r\n          btn.classList.remove('show');\r\n        }\r\n      });\r\n    });\r\n\r\n    if (e.type === 'panend') {\r\n      this.data.lastPan.x = this.data.current.x;\r\n      this.data.lastPan.y = this.data.current.y;\r\n    }\r\n  }\r\n\r\n  moveParent() {\r\n    const mq = window.matchMedia('(min-width: 801px)');\r\n    if (mq.matches) {\r\n      this.data.border = this.dom.cover.getBoundingClientRect();\r\n      const { border } = this.data;\r\n      const { padding, offset, speed } = this.config;\r\n      if (this.mouse.x < padding && border.left < -offset) { // left\r\n        this.data.last.x += speed;\r\n        this.data.current.x = this.data.last.x;\r\n        this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n      } else if (this.mouse.x > window.innerWidth - padding && border.right > window.innerWidth + offset) { // right\r\n        this.data.last.x -= speed;\r\n        this.data.current.x = this.data.last.x;\r\n        this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n      } else if (this.mouse.y < padding && border.top < -offset) { // top\r\n        this.data.last.y += speed;\r\n        this.data.current.y = this.data.last.y;\r\n        this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n      } else if (this.mouse.y > window.innerHeight - padding && border.bottom > window.innerHeight + offset) { // bottom\r\n        this.data.last.y -= speed;\r\n        this.data.current.y = this.data.last.y;\r\n        this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n      } else {\r\n        // this.data.last.x = this.math.lerp(this.data.last.x, this.data.current.x, this.data.ease);\r\n        // this.data.last.y = this.math.lerp(this.data.last.y, this.data.current.y, this.data.ease);\r\n        // this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n      }\r\n    }\r\n    this.data.last.x = this.math.lerp(this.data.last.x, this.data.current.x, this.data.ease);\r\n    this.data.last.y = this.math.lerp(this.data.last.y, this.data.current.y, this.data.ease);\r\n    this.dom.cover.style.transform = `translate3d(${this.data.last.x}px, ${this.data.last.y}px, 0)`;\r\n  }\r\n\r\n  onMobile() {\r\n    this.addMobileEvents();\r\n    requestAnimationFrame(this.run);\r\n  }\r\n\r\n  on() {\r\n    this.addEvents();\r\n    requestAnimationFrame(this.run);\r\n  }\r\n\r\n  off() {\r\n    this.cancelAnimationFrame();\r\n  }\r\n\r\n  requestAnimationFrame() {\r\n    this.rAF = requestAnimationFrame(this.run);\r\n  }\r\n\r\n  cancelAnimationFrame() {\r\n    cancelAnimationFrame(this.rAF);\r\n  }\r\n\r\n  destroy() {\r\n    this.data = null;\r\n    this.cancelAnimationFrame();\r\n  }\r\n\r\n  addMobileEvents() {\r\n    this.mc = new Hammmer.Manager(document.body);\r\n    this.mc.add(new Hammmer.Pan({\r\n      threshold: 0,\r\n      pointers: 0\r\n    }));\r\n    this.mc.on('panmove panend', this.onPan);\r\n  }\r\n\r\n  addEvents() {\r\n    document.onmousemove = this.throttle((e) => this.handleMouseMove(e), 25);\r\n    document.body.addEventListener('mouseenter', this.requestAnimationFrame);\r\n    document.body.addEventListener('mouseleave', this.cancelAnimationFrame);\r\n  }\r\n\r\n  throttle(fn, ms) {\r\n    var time, last = 0;\r\n    return function () {\r\n      var a = arguments,\r\n        t = this,\r\n        now = +(new Date),\r\n        exe = function () {\r\n          last = now;\r\n          fn.apply(t, a);\r\n        };\r\n      clearTimeout(time);\r\n      (now >= last + ms) ? exe() : time = setTimeout(exe, ms);\r\n    }\r\n  }\r\n\r\n  removeEvents() {\r\n    this.dom.coverLayer.removeEventListener('mouseenter', this.requestAnimationFrame, { passive: true })\r\n    this.dom.coverLayer.removeEventListener('mouseleave', this.cancelAnimationFrame, { passive: true })\r\n  }\r\n\r\n  init() {\r\n    // this.on();\r\n  }\r\n}\r\nexport default Smooth;","export default [\r\n  {\r\n    \"id\": \"GRETA\",\r\n    \"name\": \"Greta Thunberg\",\r\n    \"list\": \"Personnalits internationales les plus recherches\",\r\n    \"rank\": 10,\r\n    \"imgSmall\": \"assets/images/vadot/GRETA_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/GRETA_big.png\",\r\n    \"description\": \"Greta Thunberg est une militante sudoise pour la lutte contre le rchauffement climatique. Elle reoit plusieurs prix et distinctions pour son militantisme.\",\r\n  },\r\n  {\r\n    \"id\": \"ARAFAT\",\r\n    \"name\": \"DJ Arafat\",\r\n    \"list\": \"Personnalits francophones les plus recherches\",\r\n    \"rank\": 9,\r\n    \"imgSmall\": \"assets/images/vadot/ARAFAT_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/ARAFAT_big.png\",\r\n    \"description\": \"DJ Arafat, de son vrai nom Ange Didier Houon, est mort d'un accident de la route le 12/08/2019  Abidjan. Il est considr comme l'un des plus grands chanteurs d'Afrique subsaharienne.\",\r\n  },\r\n  {\r\n    \"id\": \"KARL\",\r\n    \"name\": \"Karl Lagerfeld\",\r\n    \"list\": \"Personnalits internationales les plus recherches\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/vadot/KARL_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/KARL_big.png\",\r\n    \"description\": \"Karl Otto Lagerfeld, n le 10/09/1933  Hambourg et mort le 19/02/2019  Neuilly-sur-Seine, est un grand couturier et styliste allemand ayant t le directeur artistique de la maison Chanel.\",\r\n  },\r\n  {\r\n    \"id\": \"MARIE\",\r\n    \"name\": \"Marie Laforet\",\r\n    \"list\": \"Personnalits francophones les plus recherches\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/vadot/MARIE_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/MARIE_big.png\",\r\n    \"description\": \"Marie Lafort, ne le 05/10/1939  Soulac-sur-Mer et morte le 02/11/2019 en Suisse, est une chanteuse et actrice franaise. Elle a jou dans 35 films et vendu plus de 35 millions d'albums.\",\r\n  },\r\n  {\r\n    \"id\": \"CAMERON\",\r\n    \"name\": \"Cameron Boyce\",\r\n    \"list\": \"Personnalits internationales les plus recherches\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/vadot/CAMERON_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/CAMERON_big.png\",\r\n    \"description\": \"Cameron Boyce est un acteur, danseur, chanteur et mannequin amricain, n le 28/05/1999 et mort le 06/072019  Los Angeles. Il est connu pour son rle dans la trilogie Descendants de Walt Disney.\",\r\n  },\r\n  {\r\n    \"id\": \"LUKE\",\r\n    \"name\": \"Luke Perry\",\r\n    \"list\": \"Personnalits internationales les plus recherches\",\r\n    \"rank\": 4,\r\n    \"imgSmall\": \"assets/images/vadot/LUKE_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/LUKE_big.png\",\r\n    \"description\": \"Luke Perry est un acteur et producteur amricain, n le 11/10/1966  Mansfield et mort le 04/03/2019  Burbank. Il est reconnu pour ses rles dans les sries Beverly Hills 90210 ou Riverdale.\",\r\n  },\r\n  {\r\n    \"id\": \"CHIRAC\",\r\n    \"name\": \"Jacques Chirac\",\r\n    \"list\": \"Personnalits francophones les plus recherches\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/vadot/CHIRAC_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/CHIRAC_big.png\",\r\n    \"description\": \"Jacques Chirac, n le 29/11/1932  Paris et mort le 26/09/2019 dans la mme ville, est un haut fonctionnaire et homme d'tat franais. Il ft prsident de la Rpublique franaise de 1995  2007.\",\r\n  },\r\n  {\r\n    \"id\": \"DAVID\",\r\n    \"name\": \"David Goffin\",\r\n    \"list\": \"Personnalits francophones les plus recherches\",\r\n    \"rank\": 4,\r\n    \"imgSmall\": \"assets/images/vadot/DAVID_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/DAVID_big.png\",\r\n    \"description\": \"David Goffin est un joueur de tennis professionnel belge. Il a remport quatre tournois en simple et un en double sur le circuit ATP. David Goffin est aujourdhui 11e au classement ATP.\",\r\n  },\r\n  {\r\n    \"id\": \"ANGELE\",\r\n    \"name\": \"Angle\",\r\n    \"list\": \"Personnalits francophones les plus recherches\",\r\n    \"rank\": 7,\r\n    \"imgSmall\": \"assets/images/vadot/ANGELE_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/ANGELE_big.png\",\r\n    \"description\": \"Angle est une autrice-compositrice-interprte, instrumentiste et productrice belge. Son premier album, Brol, certifi disque de diamant, s'est vendu  plus de 500 000 exemplaires.\",\r\n  },\r\n  {\r\n    \"id\": \"NOTREDAME\",\r\n    \"name\": \"Incendie Notre-Dame de Paris\",\r\n    \"list\": \"Recherches gnrales\",\r\n    \"rank\": 7,\r\n    \"imgSmall\": \"assets/images/vadot/NOTREDAME_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/NOTREDAME_big.png\",\r\n    \"description\": \"La cathdrale Notre-Dame de Paris est l'un des monuments les plus emblmatiques de Paris. Le 15/04/2019, un violent incendie endommage fortement l'difice, qui est depuis ferm au public.\",\r\n  },\r\n  {\r\n    \"id\": \"TOUR\",\r\n    \"name\": \"Tour de France  Bruxelles (Egan Bernal, vainqueur du Tour)\",\r\n    \"list\": \"vnements marquants\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/vadot/TOUR_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/TOUR_big.png\",\r\n    \"description\": \"Le Tour de France 2019 est la 106 dition du Tour de France cycliste. Le grand dpart a eu lieu le 6 juillet 2019  Bruxelles. Cette anne, Egan Bernal est devenu le plus jeune vainqueur du Tour.\",\r\n  },\r\n  {\r\n    \"id\": \"MEGHAN\",\r\n    \"name\": \"Coupe du monde de foot fminin (Meghan Rapinoe)\",\r\n    \"list\": \"vnements marquants\",\r\n    \"rank\": 5,\r\n    \"imgSmall\": \"assets/images/vadot/MEGHAN_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/MEGHAN_big.png\",\r\n    \"description\": \"Pour la huitime dition de La Coupe du monde fminine de football 2019, c'est l'quipe des tats-Unis qui remporte son 4e titre mondial. Megan Rapinoe est dsigne meilleure joueuse du tournoi.\",\r\n  },\r\n  {\r\n    \"id\": \"TOM\",\r\n    \"name\": \"Tom Van Grieken\",\r\n    \"list\": \"Personnalits belges les plus recherches\",\r\n    \"rank\": 8,\r\n    \"imgSmall\": \"assets/images/vadot/TOM_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/TOM_big.png\",\r\n    \"description\": \"Tom Van Grieken est un homme politique belge flamand. Il est le prsident du Vlaams Belang depuis le 19 octobre 2014.\",\r\n  },\r\n  {\r\n    \"id\": \"INSTAGRAM\",\r\n    \"name\": \"Comment supprimer son compte Instagram\",\r\n    \"list\": \"Comment ?\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/vadot/INSTAGRAM_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/INSTAGRAM_big.png\",\r\n    \"description\": \"Cette anne, nous avons observ une croissance de la recherche Comment supprimer son compte Instagram sur Google.\",\r\n  },\r\n  {\r\n    \"id\": \"WEIGHT\",\r\n    \"name\": \"Comment perdre du ventre/du poids\",\r\n    \"list\": \"Comment ?\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/vadot/WEIGHT_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/WEIGHT_big.png\",\r\n    \"description\": \"Cette anne, beaucoup de belges se sont inquits de savoir 'comment perdre du ventre/du poids' sur Google\",\r\n  },\r\n  {\r\n    \"id\": \"ELECTIONSBE\",\r\n    \"name\": \"Elections belges\",\r\n    \"list\": \"Comment ...?\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/vadot/ELECTIONS_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/ELECTIONS_big.png\",\r\n    \"description\": \"Les lections fdrales belges ont eu lieu le 26 mai 2019 afin d'lire les 150 membres de la Chambre des reprsentants belge. Beaucoup de belges se sont renseigns sur 'comment voter' sur Google.\",\r\n  },\r\n\r\n  {\r\n    \"id\": \"ELECTIONSEU\",\r\n    \"name\": \"Elections europennes\",\r\n    \"list\": \"Recherches gnrales\",\r\n    \"rank\": 17,\r\n    \"imgSmall\": \"assets/images/vadot/ELECTIONS_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/ELECTIONS_big.png\",\r\n    \"description\": \"Election europennes: Les lections europennes de 2019 ont eu lieu entre le 23 et le 26 mai 2019 dans les vingt-huit tats membres afin d'lire les dputs au sein du Parlement europen pour un mandat de cinq ans.\",\r\n  },\r\n  {\r\n    \"id\": \"IPHONE\",\r\n    \"name\": \"iPhone 11 (Tim Cook)\",\r\n    \"list\": \"Recherches gnrales\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/vadot/IPHONE_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/IPHONE_big.png\",\r\n    \"description\": \"L'iPhone 11, iPhone 11 Pro et iPhone 11 Pro Max, sont trois modles de la treizime gnration du smartphone de la socit Apple. Ils ont t prsents au public le 10 septembre 2019.\",\r\n  },\r\n  {\r\n    \"id\": \"BILLIE\",\r\n    \"name\": \"Billie Eilish\",\r\n    \"list\": \"Personnalits internationales les plus recherches\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/vadot/BILLIE_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/BILLIE_big.png\",\r\n    \"description\": \"Billie Eilish est une auteure-compositrice-interprte amricaine. En novembre 2019, elle sort un single se nommant Everything I wanted qui fait rapidement sa place dans les chansons  succs.\",\r\n  },\r\n  {\r\n    \"id\": \"DUNCAN\",\r\n    \"name\": \"Eurovision 2019 (Duncan Laurence)\",\r\n    \"list\": \"vnements marquants\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/vadot/DUNCAN_small.jpg\",\r\n    \"imgBig\": \"assets/images/vadot/DUNCAN_big.png\",\r\n    \"description\": \"L'Eurovision est le grand concours europen de la chanson. Duncan Laurence est un auteur-compositeur-interprte nerlandais qui remporte l'dition 2019 avec la chanson Arcade.\",\r\n  }\r\n];\r\n","export default [\r\n  {\r\n    \"id\": \"WTFOCK\",\r\n    \"name\": \"WTFock\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/marec/WTFOCK_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WTFOCK_big.png\",\r\n    \"description\": \"wtFOCK is een Belgische online serie die het reilen en zeilen van een groep tienermeisjes -en jongens op de middelbare school volgt.\",\r\n  },\r\n  {\r\n    \"id\": \"JULIE\",\r\n    \"name\": \"Julie Van Espen\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/marec/JULIE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/JULIE_big.png\",\r\n    \"description\": \"Op 4 mei 2019 verdween 23-jarige Julie Van Espen. De dood van de jonge twintiger leidde tot heel wat verontwaardiging, woede en gevoel van onveiligheid, met protest tegen seksueel geweld als gevolg. \",\r\n  },\r\n  {\r\n    \"id\": \"TOUR\",\r\n    \"name\": \"Tour de France 19\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/marec/TOUR_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/TOUR_big.png\",\r\n    \"description\": \"De eerste etappe startte op 6 juli 2019 in Brussel en eindigde op de Champs-lyses in Parijs. Egan Bernal ging lopen met de eindzege. \",\r\n  },\r\n  {\r\n    \"id\": \"LOVEISLAND\",\r\n    \"name\": \"Love Island\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 4,\r\n    \"imgSmall\": \"assets/images/marec/LOVEISLAND_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/LOVEISLAND_big.png\",\r\n    \"description\": \"Love Island is een internationaal TV-programma waarin 10 vrijgezellen in een luxueuze villa op zoek gaan naar de ware liefde.\",\r\n  },\r\n  {\r\n    \"id\": \"VOTING\",\r\n    \"name\": \"Stemtest\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 5,\r\n    \"imgSmall\": \"assets/images/marec/VOTING_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/VOTING_big.png\",\r\n    \"description\": \"De stemtest is een tool die via vraag en antwoord de meest passende partij voor de kiezer in beeld brengt. \",\r\n  },\r\n  {\r\n    \"id\": \"IPHONE\",\r\n    \"name\": \"iPhone 11\",\r\n    \"list\": \"Trending Algemeen\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/marec/IPHONE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/IPHONE_big.png\",\r\n    \"description\": \"Op 10 september 2019 werden de nieuwste iPhone 11, iPhone 11 Pro en iPhone 11 Pro Max voorgesteld aan het grote publiek ter opvolging van de iPhone XR.\",\r\n  },\r\n  {\r\n    \"id\": \"NOTREDAME\",\r\n    \"name\": \"Notre-Dame Paris\",\r\n    \"list\": \"Trending Algemeen\",\r\n    \"rank\": 7,\r\n    \"imgSmall\": \"assets/images/marec/NOTREDAME_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/NOTREDAME_big.png\",\r\n    \"description\": \"De Parijse kathedraal Notre-Dame werd op 15 april 2019 getroffen door een verwoestende brand. Miljoenen werden ingezameld om de meest bezochte bezienswaardigheid van Parijs weer op te lappen.\",\r\n  },\r\n  {\r\n    \"id\": \"JULEN\",\r\n    \"name\": \"Julen\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 8,\r\n    \"imgSmall\": \"assets/images/marec/JULEN_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/JULEN_big.png\",\r\n    \"description\": \"Op 13 januari viel peuter Julen Rosell in een 110 meter diepe put in Mlaga waarbij hij overleed aan zijn verwondingen. Na 13 dagen slaagde een reddingsteam er in om de kleuter te bereiken. \",\r\n  },\r\n  {\r\n    \"id\": \"WIMBLEDON\",\r\n    \"name\": \"Wimbledon 2019\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 9,\r\n    \"imgSmall\": \"assets/images/marec/WIMBLEDON_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WIMBLEDON_big.png\",\r\n    \"description\": \"De 113e editie van het Wimbledon Championship werd gespeeld van 1 tot 14 juli 2019. Djokovic bleef op kop, Spanjaard Rafael Nadal eindigde tweede, Roger Federer werd derde. \",\r\n  },\r\n  {\r\n    \"id\": \"EUROVISION\",\r\n    \"name\": \"Eurovision 2019\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 11,\r\n    \"imgSmall\": \"assets/images/marec/EUROVISION_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/EUROVISION_big.png\",\r\n    \"description\": \"Op 18 mei 2019 werd Eurovision georganiseerd in Expo Tel Aviv, Isral. Nederland scoorde 492 punten en won met het nummer Arcade van Duncan Laurence.\",\r\n  },\r\n  {\r\n    \"id\": \"AFRIKACUP\",\r\n    \"name\": \"Afrika Cup 2019\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 12,\r\n    \"imgSmall\": \"assets/images/marec/AFRIKACUP_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/AFRIKACUP_big.png\",\r\n    \"description\": \"Voor de 32ste keer werd het Afrikaans kampioenschap voetbal gespeeld. Tussen 21 juni 2019 en 19 juli gaven de deelnemende landen het beste van zichzelf. Algerije werd de grote winnaar.\",\r\n  },\r\n  {\r\n    \"id\": \"MOBISCORE\",\r\n    \"name\": \"Mobiscore\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 13,\r\n    \"imgSmall\": \"assets/images/marec/MOBISCORE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/MOBISCORE_big.png\",\r\n    \"description\": \"De Mobiscore berekent de afstand van elk adres in Vlaanderen naar verschillende soorten voorzieningen. Hoe hoger de score, hoe lager de mobiliteits- en milieu-impact van je woonplaats.\",\r\n  },\r\n  {\r\n    \"id\": \"VERKIEZINGEN\",\r\n    \"name\": \"Verkiezingen 26 mei\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 17,\r\n    \"imgSmall\": \"assets/images/marec/VERKIEZINGEN_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/VERKIEZINGEN_big.png\",\r\n    \"description\": \"De Belgische federale verkiezingen van 2019 werden georganiseerd op zondag 26 mei 2019, op dezelfde dag als de Europese verkiezingen van 2019 en de verkiezingen voor de deelstaten.\",\r\n  },\r\n  {\r\n    \"id\": \"PROLEAGUE\",\r\n    \"name\": \"Jupiler Pro League 2019\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 18,\r\n    \"imgSmall\": \"assets/images/marec/PROLEAGUE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/PROLEAGUE_big.png\",\r\n    \"description\": \"De voetbalcompetitie tussen 16 teams startte eind juli en zal eindigen in maart 2020. De Belgische competitie startte in 1895 en is de oudste op het Europese vasteland.\",\r\n  },\r\n  {\r\n    \"id\": \"WKVROUWEN\",\r\n    \"name\": \"WK voetbal vrouwen 2019\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 20,\r\n    \"imgSmall\": \"assets/images/marec/WKVROUWEN_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WKVROUWEN_big.png\",\r\n    \"description\": \"Het WK 2019 is de achtste editie van het wereldkampioenschap voetbal voor vrouwen. Aan het toernooi deden 24 landen mee. De eerste wedstrijd werd gespeeld op 7 juni 2019, de finale op 7 juli 2019.\",\r\n  },\r\n  {\r\n    \"id\": \"CHRISTOPHE\",\r\n    \"name\": \"Christophe Lambrecht\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/marec/CHRISTOPHE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/CHRISTOPHE_big.png\",\r\n    \"description\": \"Radiopresentator Christophe Lambrecht overleed op 5 mei op 48-jarige leeftijd aan hartfalen. De stem van Studio Brussel liet een vriendin en drie kinderen na.\",\r\n  },\r\n  {\r\n    \"id\": \"PAUL\",\r\n    \"name\": \"Paul Severs\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/marec/PAUL_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/PAUL_big.png\",\r\n    \"description\": \"Op 9 april 2019 overleed Vlaamse charmezanger Paul Severs. Hij brak door met het nummer Ik ben verliefd op jou en was gekend van het programma Tien om te zien.\",\r\n  },\r\n  {\r\n    \"id\": \"BJORG\",\r\n    \"name\": \"Bjorg Lambrecht\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 4,\r\n    \"imgSmall\": \"assets/images/marec/BJORG_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/BJORG_big.png\",\r\n    \"description\": \"Bjorg Lambrecht, wielrenner en n van de grootste klimtalenten van zijn generatie, overleed op 5 augustus 2019 na een zware val in de Ronde van Polen.\",\r\n  },\r\n  {\r\n    \"id\": \"THEO\",\r\n    \"name\": \"Tho Hayez\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 5,\r\n    \"imgSmall\": \"assets/images/marec/THEO_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/THEO_big.png\",\r\n    \"description\": \"Belgische backpacker Tho Hayez verdween op 31 mei 2019 en werd het laatst gezien in het Australische dorp Byron Bay. De zoektocht naar Tho loopt nog steeds.\",\r\n  }\r\n  ,\r\n  {\r\n    \"id\": \"WOUT\",\r\n    \"name\": \"Wout van Aert\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/marec/WOUT_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WOUT_big.png\",\r\n    \"description\": \"Topfavoriet Wout van Aert kwam tijdens de Tour de France op 19 juli ongelukkig ten val na een hapering met de wegafsluiting. Wout hoopt om snel zijn comeback te maken.\",\r\n  }\r\n  ,\r\n  {\r\n    \"id\": \"FLOR\",\r\n    \"name\": \"Flor Decleir\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 7,\r\n    \"imgSmall\": \"assets/images/marec/FLOR_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/FLOR_big.png\",\r\n    \"description\": \"Flor, zoon van Jan Decleir, is een Belgische acteur die reeds rollen wist te versieren in Vossenstreken en Geub. In 2019 maakte hij ook als eerste Decleir zijn intrede in De Slimste Mens ter Wereld.  \",\r\n  }\r\n  ,\r\n  {\r\n    \"id\": \"MARIEKE\",\r\n    \"name\": \"Marieke Vervoort\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 8,\r\n    \"imgSmall\": \"assets/images/marec/MARIEKE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/MARIEKE_big.png\",\r\n    \"description\": \"Wielemie beoefende atletiek, zeilwagenrijden en triatlon. Marieke nam 2 keer deel aan de Paralympische Spelen en won hierbij tal van medailles. Op 22 oktober stierf ze na een strijd tegen een spierziekte.\",\r\n  }\r\n  ,\r\n  {\r\n    \"id\": \"TOM\",\r\n    \"name\": \"Tom van Grieken\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 9,\r\n    \"imgSmall\": \"assets/images/marec/TOM_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/TOM_big.png\",\r\n    \"description\": \"Tom van Grieken werd na de verkiezingen van 2019 met een monsterscore van 97,4% opnieuw verkozen tot voorzitter van Vlaams Belang.\",\r\n  },\r\n  {\r\n    \"id\": \"PIA\",\r\n    \"name\": \"Pia\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 10,\r\n    \"imgSmall\": \"assets/images/marec/PIA_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/PIA_big.png\",\r\n    \"description\": \"Pia lijdt aan de zeldzame spierziekte SMA en had het levensreddende medicijn Zolgensma nodig om langer te kunnen leven. Het medicijn kostte 1,9 miljoen euro. Dit bedrag werd op 2 dagen tijd ingezameld door crowdfunding.\",\r\n  },\r\n  {\r\n    \"id\": \"JOKE\",\r\n    \"name\": \"Joke Schauvliege\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 11,\r\n    \"imgSmall\": \"assets/images/marec/JOKE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/JOKE_big.png\",\r\n    \"description\": \"Joke Schauvliege stapte begin februari 2019 op als Vlaams minister van Natuur, Landbouw en Omgeving. De komende 5 jaar blijft ze parlementslid voor CD&V.\",\r\n  },\r\n  {\r\n    \"id\": \"WILLY\",\r\n    \"name\": \"Willy Willy\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 12,\r\n    \"imgSmall\": \"assets/images/marec/WILLY_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WILLY_big.png\",\r\n    \"description\": \"Willy Lambregt, bekend als Willy Willy en onder meer deel van The Scabs, overleed op 13 februari 2019 na een strijd tegen kanker.\",\r\n  },\r\n  {\r\n    \"id\": \"DRIES\",\r\n    \"name\": \"Dries Van Langenhove\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 13,\r\n    \"imgSmall\": \"assets/images/marec/DRIES_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/DRIES_big.png\",\r\n    \"description\": \"Dries Van Langenhove is de oprichter van het extreemrechtse Schild & Vrienden. Van Langenhove trekt sinds 9 januari 2019 als onafhankelijke een gemeenschappelijke Kamerlijst met Vlaams Belang.\",\r\n  },\r\n  {\r\n    \"id\": \"ASTRID\",\r\n    \"name\": \"Astrid Stockman\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 14,\r\n    \"imgSmall\": \"assets/images/marec/ASTRID_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/ASTRID_big.png\",\r\n    \"description\": \"Astrid Stockman is een 32-jarige Belgische sopraan met internationale bekendheid. In het seizoen van 2019 nam ze met succes deel aan De Slimste Mens ter Wereld.\",\r\n  },\r\n  {\r\n    \"id\": \"DAVID\",\r\n    \"name\": \"David Goffin\",\r\n    \"list\": \"Trending Belgen\",\r\n    \"rank\": 15,\r\n    \"imgSmall\": \"assets/images/marec/DAVID_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/DAVID_big.png\",\r\n    \"description\": \"David Goffin is een professionele Belgische tennisspeler en sluit het seizoen van 2019 af op de 11e plaats op ATP ranking. \",\r\n  },\r\n  {\r\n    \"id\": \"KARL\",\r\n    \"name\": \"Karl Lagerfeld\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 10,\r\n    \"imgSmall\": \"assets/images/marec/KARL_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/KARL_big.png\",\r\n    \"description\": \"Karl Otto Lagerfeld, geboren op 10/09/1933 in Hamburg, stierf op 19/02/2019 in Neuilly-sur-Seine. Karl was een grote Duitse modeontwerper en stylist en artistiek directeur van Chanel.\",\r\n  },\r\n  {\r\n    \"id\": \"NEYMAR\",\r\n    \"name\": \"Neymar\",\r\n    \"list\": \"Trending internationaal\",\r\n    \"rank\": 5,\r\n    \"imgSmall\": \"assets/images/marec/NEYMAR_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/NEYMAR_big.png\",\r\n    \"description\": \"Neymar, speler van Paris Saint-Germain, leed het afgelopen seizoen aan verschillende blessures. Eerder werd een contractverlenging bij PSG aangeboden, maar die liet Neymar voorlopig links liggen.\",\r\n  },\r\n  {\r\n    \"id\": \"BILLIE\",\r\n    \"name\": \"Billie Eilish\",\r\n    \"list\": \"Trending internationaal\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/marec/BILLIE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/BILLIE_big.png\",\r\n    \"description\": \"Billie Eilish is een Amerikaanse singer-songwriter. Begin 2019 scoorde ze een monsterhit in ons land met Bad Guy.\",\r\n  },\r\n  {\r\n    \"id\": \"GRETA\",\r\n    \"name\": \"Greta Thunberg\",\r\n    \"list\": \"Trending internationaal\",\r\n    \"rank\": 10,\r\n    \"imgSmall\": \"assets/images/marec/GRETA_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/GRETA_big.png\",\r\n    \"description\": \"Greta Thunberg is een Zweedse activiste voor de strijd tegen de opwarming van de aarde. Ze ontving verschillende prijzen en onderscheidingen voor haar activisme.\",\r\n  },\r\n  {\r\n    \"id\": \"RAMADAN\",\r\n    \"name\": \"Ramadan 2019\",\r\n    \"list\": \"Trending evenementen\",\r\n    \"rank\": 7,\r\n    \"imgSmall\": \"assets/images/marec/RAMADAN_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/RAMADAN_big.png\",\r\n    \"description\": \"De ramadan is de negende maand op de Islamitische kalender en is de jaarlijkse periode waarin moslims vasten.\",\r\n  },\r\n  {\r\n    \"id\": \"VOTING\",\r\n    \"name\": \"Hoe stemmen op 26 mei\",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/marec/VOTING_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/VOTING_big.png\",\r\n    \"description\": \"Om ons optimaal voor te bereiden voor de verkiezingen van 2019, zochten we massaal naar de wijze van het stemmen.\",\r\n  },\r\n  {\r\n    \"id\": \"KIP\",\r\n    \"name\": \"Hoe oud wordt een kip\",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/marec/KIP_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/KIP_big.png\",\r\n    \"description\": \"In 2019 waren veel mensen in Belgi nieuwsgierig naar de maximumleeftijd van een kip.\",\r\n  },\r\n  {\r\n    \"id\": \"USTIME\",\r\n    \"name\": \"Hoe laat is het in Amerika\",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/marec/USTIME_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/USTIME_big.png\",\r\n    \"description\": \"Al hangt het af van verschillende tijdzones, toch was de vraag naar het tijdstip in Amerika erg groot.\",\r\n  },\r\n  {\r\n    \"id\": \"VISUM\",\r\n    \"name\": \"Hoe zit het met mijn visumaanvraag\",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 4,\r\n    \"imgSmall\": \"assets/images/marec/VISUM_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/VISUM_big.png\",\r\n    \"description\": \"Een aanzienlijk aantal personen in Belgi zocht in 2019 naar het verloop van hun visumaanvraag.\",\r\n  },\r\n  {\r\n    \"id\": \"WEIGHT\",\r\n    \"name\": \"Hoe snel afvallen\",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 5,\r\n    \"imgSmall\": \"assets/images/marec/WEIGHT_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/WEIGHT_big.png\",\r\n    \"description\": \"De zoektocht via Google naar de snelste manier van afvallen was erg populair in 2019.\",\r\n  },\r\n  {\r\n    \"id\": \"CONFEDERALISME\",\r\n    \"name\": \"Wat is confederalisme?\",\r\n    \"list\": \"Trending wat is?\",\r\n    \"rank\": 2,\r\n    \"imgSmall\": \"assets/images/marec/CONFEDERALISME_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/CONFEDERALISME_big.png\",\r\n    \"description\": \"De betekenis van confederalisme werd via Google een veelgezocht onderwerp.\",\r\n  },\r\n  {\r\n    \"id\": \"LEGIONELLA\",\r\n    \"name\": \"Wat is legionella?\",\r\n    \"list\": \"Trending wat is?\",\r\n    \"rank\": 3,\r\n    \"imgSmall\": \"assets/images/marec/LEGIONELLA_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/LEGIONELLA_big.png\",\r\n    \"description\": \"In 2019 zochten we massaal naar meer informatie over de bacterie legionella.\",\r\n  }\r\n  ,\r\n  {\r\n    \"id\": \"LUKE\",\r\n    \"name\": \"Luke Perry\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 15,\r\n    \"imgSmall\": \"assets/images/marec/LUKE_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/LUKE_big.png\",\r\n    \"description\": \"De Beverly Hills, 90210-ster overleed in maart ten gevolge van een beroerte. Verder werd Luke bekend door de hitserie Riverdale en zou hij een rol spelen in Once Upon a Time in Hollywood.\",\r\n  },\r\n  {\r\n    \"id\": \"SUN\",\r\n    \"name\": \"Hoe warm is het? \",\r\n    \"list\": \"Trending hoe?\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/marec/SUN_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/SUN_big.png\",\r\n    \"description\": \"In 2019 waren tal van personen in Belgi benieuwd naar de temperatuur van de dag.\",\r\n  },\r\n  {\r\n    \"id\": \"CAMERON\",\r\n    \"name\": \"Cameron Boyce\",\r\n    \"list\": \"Trending algemeen\",\r\n    \"rank\": 14,\r\n    \"imgSmall\": \"assets/images/marec/CAMERON_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/CAMERON_big.png\",\r\n    \"description\": \"De jonge Amerikaanse acteur, bekend van onder andere Disney Channel, overleed afgelopen zomer aan de gevolgen van epilepsie. Cameron werd 20 jaar.\",\r\n  },\r\n  {\r\n    \"id\": \"ROMELU\",\r\n    \"name\": \"Romelu Lukaku\",\r\n    \"list\": \"Meest trending Rode Duivels\",\r\n    \"rank\": 1,\r\n    \"imgSmall\": \"assets/images/marec/ROMELU_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/ROMELU_big.png\",\r\n    \"description\": \"Romelu Lukaku werd in 2019 topscorer aller tijden voor de Rode Duivels, en verkaste van Manchester United naar Inter Milaan.\",\r\n  },\r\n  {\r\n    \"id\": \"EURO2020\",\r\n    \"name\": \"EURO 2020\",\r\n    \"list\": \"Meest trending events\",\r\n    \"rank\": 9,\r\n    \"imgSmall\": \"assets/images/marec/EURO2020_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/EURO2020_big.png\",\r\n    \"description\": \"Het EK voetbal in 2020 deed Belgen nu al watertanden naar weken voetbalplezier. De Rode Duivels behaalden een perfect rapport van 30/30 in de kwalificatie.\",\r\n  },\r\n  {\r\n    \"id\": \"TOMORROWLAND\",\r\n    \"name\": \"Tomorrowland\",\r\n    \"list\": \"Meest trending events\",\r\n    \"rank\": 6,\r\n    \"imgSmall\": \"assets/images/marec/TOMORROWLAND_small.jpg\",\r\n    \"imgBig\": \"assets/images/marec/TOMORROWLAND_big.png\",\r\n    \"description\": \"Tomorrowland, het muziekfestival in Boom, was ook dit jaar n van de meest gezochte events in ons land.\",\r\n  }\r\n\r\n];\r\n","import './main';\n// import './morph';","/**\r\n * main.js\r\n * https://yearinsearch.be\r\n *\r\n * Licensed under the MIT license.\r\n * http://www.opensource.org/licenses/mit-license.php\r\n * \r\n * Copyright 2019, The Reference NV.\r\n * https://www.the-reference.com\r\n */\r\n\r\nimport 'nodelist-foreach-polyfill';\r\n\r\nimport Hammmer from 'hammerjs';\r\nimport Popup from './Popup';\r\nimport dataNl from './data-nl';\r\nimport dataFr from './data-fr';\r\nimport anime from 'animejs';\r\nimport Layer from './Layer';\r\nimport Smooth from './Smooth';\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n\t// variables\r\n\tconst body = document.querySelector('body');\r\n\tconst coverLayer = document.querySelector('.cover-layer');\r\n\tconst smoothLayer = document.querySelector('.cover-layer .smooth-nav');\r\n\tconst coverSvgLayer = document.querySelector('.cover-svg-layer');\r\n\tconst skew = document.querySelector('.skew');\r\n\tconst topLayer = document.querySelector('.top-layer');\r\n\tconst holeLayer = document.querySelector('.hole-layer');\r\n\t//const btnStart = document.querySelector('.top-layer button');\r\n\tconst btnStart = document.querySelector('.eye__text');\r\n\tconst cursor = document.querySelector('.cursor');\r\n\tlet pos = { // position of cover\r\n\t\tx: 0,\r\n\t\ty: 0,\r\n\t}\r\n\r\n\tlet center = {\r\n\t\tx: window.innerWidth / 2,\r\n\t\ty: window.innerHeight / 2 + 25,\r\n\t}\r\n\tlet popup;\r\n\tlet layerObjects = [];\r\n\tlet smooth;\r\n\tlet borders = smoothLayer.getBoundingClientRect();\r\n\r\n\t// functions\r\n\tconst init = () => {\r\n\t\t// create popup\r\n\t\tpopup = new Popup(document.querySelector('.popup'), smoothLayer);\r\n\t\thandleMarkers();\r\n\t\tbtnStart.addEventListener('click', start);\r\n\r\n\t\twindow.addEventListener('resize', setInitialButtonPos);\r\n\t\tsetInitialButtonPos();\r\n\r\n\t}\r\n\r\n\tconst setInitialButtonPos = () => {\r\n\t\tconst mq = window.matchMedia('(min-width: 801px)');\r\n\t\tdocument.querySelectorAll('.eye').forEach((eye, i) => {\r\n\t\t\teye.setAttribute('transform', `translate(${window.innerWidth / 2}, ${window.innerHeight / 2 + 50})`);\r\n\t\t});\r\n\t}\r\n\r\n\tconst start = (e) => {\r\n\t\ttopLayer.classList.add('started');\r\n\t\tholeLayer.classList.add('started');\r\n\t\tbtnStart.classList.add('started');\r\n\t\tsmooth = new Smooth(popup, layerObjects);\r\n\t\tpopup.setSmooth(smooth);\r\n\t\tconst mq = window.matchMedia('(min-width: 801px)');\r\n\t\tif (mq.matches) {\r\n\t\t\tcursor.style.transform = `translate3d(${e.clientX}px, ${e.clientY}px, 0)`;\r\n\t\t\tsmooth.on();\r\n\t\t\tanime({\r\n\t\t\t\ttargets: '#hole .eye',\r\n\t\t\t\twidth: 350,\r\n\t\t\t\theight: 350,\r\n\t\t\t\trx: 175,\r\n\t\t\t\tx: -175,\r\n\t\t\t\ty: -175,\r\n\t\t\t\tduration: 300,\r\n\t\t\t\teasing: 'easeInOutBack',\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tsmooth.onMobile();\r\n\t\t\tanime({\r\n\t\t\t\ttargets: '#hole .eye',\r\n\t\t\t\twidth: 300,\r\n\t\t\t\theight: 300,\r\n\t\t\t\trx: 150,\r\n\t\t\t\tx: -150,\r\n\t\t\t\ty: -150,\r\n\t\t\t\tduration: 300,\r\n\t\t\t\teasing: 'easeInOutBack',\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tconst handleMarkers = () => {\r\n\t\tconst layers = coverSvgLayer.querySelectorAll('.layer');\r\n\t\tconst lang = document.getElementsByTagName('html')[0].getAttribute('lang');\r\n\r\n\t\tif (lang == \"nl\") {\r\n\t\t\tlayers.forEach(layer => {\r\n\t\t\t\tlayerObjects.push(new Layer(layer, cursor, dataNl, popup));\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (lang == \"fr\") {\r\n\t\t\tlayers.forEach(layer => {\r\n\t\t\t\tlayerObjects.push(new Layer(layer, cursor, dataFr, popup));\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst initMobileControls = () => {\r\n\t\t// mobile controls\r\n\t\tlet last_x = 0;\r\n\t\tlet last_y = 0;\r\n\t\tconst mc = new Hammmer.Manager(body);\r\n\t\tmc.add(new Hammmer.Pan({\r\n\t\t\tthreshold: 0,\r\n\t\t\tpointers: 0\r\n\t\t}));\r\n\t\tmc.on('panmove panend', onPan);\r\n\r\n\t\tfunction onPan(e) {\r\n\t\t\tif (e.type === 'panmove') {\r\n\t\t\t\t// console.log(e.deltaX, e.deltaY);\r\n\t\t\t\tpos = {\r\n\t\t\t\t\tx: last_x + e.deltaX,\r\n\t\t\t\t\ty: last_y + e.deltaY,\r\n\t\t\t\t}\r\n\t\t\t\tconst value = `translate3d(${pos.x}px, ${pos.y}px, 0px)`;\r\n\t\t\t\tsmoothLayer.style.webkitTransform = value;\r\n\t\t\t\tsmoothLayer.style.mozTransform = value;\r\n\t\t\t\tsmoothLayer.style.transform = value;\r\n\t\t\t}\r\n\r\n\t\t\tlayerObjects.forEach(layer => {\r\n\t\t\t\tlayer.buttons.forEach(btn => {\r\n\t\t\t\t\tconst pos = btn.getBoundingClientRect();\r\n\t\t\t\t\tconst dist = Math.sqrt(Math.pow(Math.abs(center.x - pos.left), 2) + Math.pow(Math.abs(center.y - pos.top), 2));\r\n\t\t\t\t\t// const dist = Math.hypot(center.x - pos.left, center.y - center.top);\r\n\t\t\t\t\tif (dist < 120) {\r\n\t\t\t\t\t\tbtn.classList.add('show');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbtn.classList.remove('show');\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\tif (e.type === 'panend') {\r\n\t\t\t\tlast_x = pos.x;\r\n\t\t\t\tlast_y = pos.y;\r\n\t\t\t\tconsole.log(last_x, last_y);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tinit();\r\n});","/*\n * anime.js v3.1.0\n * (c) 2019 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */\n\n'use strict';\n\n// Defaults\n\nvar defaultInstanceSettings = {\n  update: null,\n  begin: null,\n  loopBegin: null,\n  changeBegin: null,\n  change: null,\n  changeComplete: null,\n  loopComplete: null,\n  complete: null,\n  loop: 1,\n  direction: 'normal',\n  autoplay: true,\n  timelineOffset: 0\n};\n\nvar defaultTweenSettings = {\n  duration: 1000,\n  delay: 0,\n  endDelay: 0,\n  easing: 'easeOutElastic(1, .5)',\n  round: 0\n};\n\nvar validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];\n\n// Caching\n\nvar cache = {\n  CSS: {},\n  springs: {}\n};\n\n// Utils\n\nfunction minMax(val, min, max) {\n  return Math.min(Math.max(val, min), max);\n}\n\nfunction stringContains(str, text) {\n  return str.indexOf(text) > -1;\n}\n\nfunction applyArguments(func, args) {\n  return func.apply(null, args);\n}\n\nvar is = {\n  arr: function (a) { return Array.isArray(a); },\n  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },\n  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },\n  svg: function (a) { return a instanceof SVGElement; },\n  inp: function (a) { return a instanceof HTMLInputElement; },\n  dom: function (a) { return a.nodeType || is.svg(a); },\n  str: function (a) { return typeof a === 'string'; },\n  fnc: function (a) { return typeof a === 'function'; },\n  und: function (a) { return typeof a === 'undefined'; },\n  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },\n  rgb: function (a) { return /^rgb/.test(a); },\n  hsl: function (a) { return /^hsl/.test(a); },\n  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },\n  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }\n};\n\n// Easings\n\nfunction parseEasingParameters(string) {\n  var match = /\\(([^)]+)\\)/.exec(string);\n  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];\n}\n\n// Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js\n\nfunction spring(string, duration) {\n\n  var params = parseEasingParameters(string);\n  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);\n  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);\n  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);\n  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);\n  var w0 = Math.sqrt(stiffness / mass);\n  var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n  var a = 1;\n  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n\n  function solver(t) {\n    var progress = duration ? (duration * t) / 1000 : t;\n    if (zeta < 1) {\n      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n    } else {\n      progress = (a + b * progress) * Math.exp(-progress * w0);\n    }\n    if (t === 0 || t === 1) { return t; }\n    return 1 - progress;\n  }\n\n  function getDuration() {\n    var cached = cache.springs[string];\n    if (cached) { return cached; }\n    var frame = 1/6;\n    var elapsed = 0;\n    var rest = 0;\n    while(true) {\n      elapsed += frame;\n      if (solver(elapsed) === 1) {\n        rest++;\n        if (rest >= 16) { break; }\n      } else {\n        rest = 0;\n      }\n    }\n    var duration = elapsed * frame * 1000;\n    cache.springs[string] = duration;\n    return duration;\n  }\n\n  return duration ? solver : getDuration;\n\n}\n\n// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n\nfunction steps(steps) {\n  if ( steps === void 0 ) steps = 10;\n\n  return function (t) { return Math.round(t * steps) * (1 / steps); };\n}\n\n// BezierEasing https://github.com/gre/bezier-easing\n\nvar bezier = (function () {\n\n  var kSplineTableSize = 11;\n  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\n  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }\n  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }\n  function C(aA1)      { return 3.0 * aA1 }\n\n  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }\n  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }\n\n  function binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX, currentT, i = 0;\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }\n    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);\n    return currentT;\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (var i = 0; i < 4; ++i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n      if (currentSlope === 0.0) { return aGuessT; }\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  }\n\n  function bezier(mX1, mY1, mX2, mY2) {\n\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }\n    var sampleValues = new Float32Array(kSplineTableSize);\n\n    if (mX1 !== mY1 || mX2 !== mY2) {\n      for (var i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n      }\n    }\n\n    function getTForX(aX) {\n\n      var intervalStart = 0;\n      var currentSample = 1;\n      var lastSample = kSplineTableSize - 1;\n\n      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n        intervalStart += kSampleStepSize;\n      }\n\n      --currentSample;\n\n      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n      var guessForT = intervalStart + dist * kSampleStepSize;\n      var initialSlope = getSlope(guessForT, mX1, mX2);\n\n      if (initialSlope >= 0.001) {\n        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n      } else if (initialSlope === 0.0) {\n        return guessForT;\n      } else {\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n      }\n\n    }\n\n    return function (x) {\n      if (mX1 === mY1 && mX2 === mY2) { return x; }\n      if (x === 0 || x === 1) { return x; }\n      return calcBezier(getTForX(x), mY1, mY2);\n    }\n\n  }\n\n  return bezier;\n\n})();\n\nvar penner = (function () {\n\n  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\n  var eases = { linear: function () { return function (t) { return t; }; } };\n\n  var functionEasings = {\n    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },\n    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },\n    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },\n    Bounce: function () { return function (t) {\n      var pow2, b = 4;\n      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}\n      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)\n    }; },\n    Elastic: function (amplitude, period) {\n      if ( amplitude === void 0 ) amplitude = 1;\n      if ( period === void 0 ) period = .5;\n\n      var a = minMax(amplitude, 1, 10);\n      var p = minMax(period, .1, 2);\n      return function (t) {\n        return (t === 0 || t === 1) ? t : \n          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);\n      }\n    }\n  };\n\n  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];\n\n  baseEasings.forEach(function (name, i) {\n    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };\n  });\n\n  Object.keys(functionEasings).forEach(function (name) {\n    var easeIn = functionEasings[name];\n    eases['easeIn' + name] = easeIn;\n    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };\n    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : \n      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };\n  });\n\n  return eases;\n\n})();\n\nfunction parseEasings(easing, duration) {\n  if (is.fnc(easing)) { return easing; }\n  var name = easing.split('(')[0];\n  var ease = penner[name];\n  var args = parseEasingParameters(easing);\n  switch (name) {\n    case 'spring' : return spring(easing, duration);\n    case 'cubicBezier' : return applyArguments(bezier, args);\n    case 'steps' : return applyArguments(steps, args);\n    default : return applyArguments(ease, args);\n  }\n}\n\n// Strings\n\nfunction selectString(str) {\n  try {\n    var nodes = document.querySelectorAll(str);\n    return nodes;\n  } catch(e) {\n    return;\n  }\n}\n\n// Arrays\n\nfunction filterArray(arr, callback) {\n  var len = arr.length;\n  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    if (i in arr) {\n      var val = arr[i];\n      if (callback.call(thisArg, val, i, arr)) {\n        result.push(val);\n      }\n    }\n  }\n  return result;\n}\n\nfunction flattenArray(arr) {\n  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);\n}\n\nfunction toArray(o) {\n  if (is.arr(o)) { return o; }\n  if (is.str(o)) { o = selectString(o) || o; }\n  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }\n  return [o];\n}\n\nfunction arrayContains(arr, val) {\n  return arr.some(function (a) { return a === val; });\n}\n\n// Objects\n\nfunction cloneObject(o) {\n  var clone = {};\n  for (var p in o) { clone[p] = o[p]; }\n  return clone;\n}\n\nfunction replaceObjectProps(o1, o2) {\n  var o = cloneObject(o1);\n  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }\n  return o;\n}\n\nfunction mergeObjects(o1, o2) {\n  var o = cloneObject(o1);\n  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }\n  return o;\n}\n\n// Colors\n\nfunction rgbToRgba(rgbValue) {\n  var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n  return rgb ? (\"rgba(\" + (rgb[1]) + \",1)\") : rgbValue;\n}\n\nfunction hexToRgba(hexValue) {\n  var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );\n  var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  var r = parseInt(rgb[1], 16);\n  var g = parseInt(rgb[2], 16);\n  var b = parseInt(rgb[3], 16);\n  return (\"rgba(\" + r + \",\" + g + \",\" + b + \",1)\");\n}\n\nfunction hslToRgba(hslValue) {\n  var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n  var h = parseInt(hsl[1], 10) / 360;\n  var s = parseInt(hsl[2], 10) / 100;\n  var l = parseInt(hsl[3], 10) / 100;\n  var a = hsl[4] || 1;\n  function hue2rgb(p, q, t) {\n    if (t < 0) { t += 1; }\n    if (t > 1) { t -= 1; }\n    if (t < 1/6) { return p + (q - p) * 6 * t; }\n    if (t < 1/2) { return q; }\n    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }\n    return p;\n  }\n  var r, g, b;\n  if (s == 0) {\n    r = g = b = l;\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1/3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1/3);\n  }\n  return (\"rgba(\" + (r * 255) + \",\" + (g * 255) + \",\" + (b * 255) + \",\" + a + \")\");\n}\n\nfunction colorToRgb(val) {\n  if (is.rgb(val)) { return rgbToRgba(val); }\n  if (is.hex(val)) { return hexToRgba(val); }\n  if (is.hsl(val)) { return hslToRgba(val); }\n}\n\n// Units\n\nfunction getUnit(val) {\n  var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n  if (split) { return split[1]; }\n}\n\nfunction getTransformUnit(propName) {\n  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }\n  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }\n}\n\n// Values\n\nfunction getFunctionValue(val, animatable) {\n  if (!is.fnc(val)) { return val; }\n  return val(animatable.target, animatable.id, animatable.total);\n}\n\nfunction getAttribute(el, prop) {\n  return el.getAttribute(prop);\n}\n\nfunction convertPxToUnit(el, value, unit) {\n  var valueUnit = getUnit(value);\n  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }\n  var cached = cache.CSS[value + unit];\n  if (!is.und(cached)) { return cached; }\n  var baseline = 100;\n  var tempEl = document.createElement(el.tagName);\n  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;\n  parentEl.appendChild(tempEl);\n  tempEl.style.position = 'absolute';\n  tempEl.style.width = baseline + unit;\n  var factor = baseline / tempEl.offsetWidth;\n  parentEl.removeChild(tempEl);\n  var convertedUnit = factor * parseFloat(value);\n  cache.CSS[value + unit] = convertedUnit;\n  return convertedUnit;\n}\n\nfunction getCSSValue(el, prop, unit) {\n  if (prop in el.style) {\n    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';\n    return unit ? convertPxToUnit(el, value, unit) : value;\n  }\n}\n\nfunction getAnimationType(el, prop) {\n  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }\n  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }\n  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }\n  if (el[prop] != null) { return 'object'; }\n}\n\nfunction getElementTransforms(el) {\n  if (!is.dom(el)) { return; }\n  var str = el.style.transform || '';\n  var reg  = /(\\w+)\\(([^)]*)\\)/g;\n  var transforms = new Map();\n  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }\n  return transforms;\n}\n\nfunction getTransformValue(el, propName, animatable, unit) {\n  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);\n  var value = getElementTransforms(el).get(propName) || defaultVal;\n  if (animatable) {\n    animatable.transforms.list.set(propName, value);\n    animatable.transforms['last'] = propName;\n  }\n  return unit ? convertPxToUnit(el, value, unit) : value;\n}\n\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n  switch (getAnimationType(target, propName)) {\n    case 'transform': return getTransformValue(target, propName, animatable, unit);\n    case 'css': return getCSSValue(target, propName, unit);\n    case 'attribute': return getAttribute(target, propName);\n    default: return target[propName] || 0;\n  }\n}\n\nfunction getRelativeValue(to, from) {\n  var operator = /^(\\*=|\\+=|-=)/.exec(to);\n  if (!operator) { return to; }\n  var u = getUnit(to) || 0;\n  var x = parseFloat(from);\n  var y = parseFloat(to.replace(operator[0], ''));\n  switch (operator[0][0]) {\n    case '+': return x + y + u;\n    case '-': return x - y + u;\n    case '*': return x * y + u;\n  }\n}\n\nfunction validateValue(val, unit) {\n  if (is.col(val)) { return colorToRgb(val); }\n  if (/\\s/g.test(val)) { return val; }\n  var originalUnit = getUnit(val);\n  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n  if (unit) { return unitLess + unit; }\n  return unitLess;\n}\n\n// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes\n// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744\n\nfunction getDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\nfunction getCircleLength(el) {\n  return Math.PI * 2 * getAttribute(el, 'r');\n}\n\nfunction getRectLength(el) {\n  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);\n}\n\nfunction getLineLength(el) {\n  return getDistance(\n    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, \n    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}\n  );\n}\n\nfunction getPolylineLength(el) {\n  var points = el.points;\n  var totalLength = 0;\n  var previousPos;\n  for (var i = 0 ; i < points.numberOfItems; i++) {\n    var currentPos = points.getItem(i);\n    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }\n    previousPos = currentPos;\n  }\n  return totalLength;\n}\n\nfunction getPolygonLength(el) {\n  var points = el.points;\n  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n}\n\n// Path animation\n\nfunction getTotalLength(el) {\n  if (el.getTotalLength) { return el.getTotalLength(); }\n  switch(el.tagName.toLowerCase()) {\n    case 'circle': return getCircleLength(el);\n    case 'rect': return getRectLength(el);\n    case 'line': return getLineLength(el);\n    case 'polyline': return getPolylineLength(el);\n    case 'polygon': return getPolygonLength(el);\n  }\n}\n\nfunction setDashoffset(el) {\n  var pathLength = getTotalLength(el);\n  el.setAttribute('stroke-dasharray', pathLength);\n  return pathLength;\n}\n\n// Motion path\n\nfunction getParentSvgEl(el) {\n  var parentEl = el.parentNode;\n  while (is.svg(parentEl)) {\n    if (!is.svg(parentEl.parentNode)) { break; }\n    parentEl = parentEl.parentNode;\n  }\n  return parentEl;\n}\n\nfunction getParentSvg(pathEl, svgData) {\n  var svg = svgData || {};\n  var parentSvgEl = svg.el || getParentSvgEl(pathEl);\n  var rect = parentSvgEl.getBoundingClientRect();\n  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');\n  var width = rect.width;\n  var height = rect.height;\n  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);\n  return {\n    el: parentSvgEl,\n    viewBox: viewBox,\n    x: viewBox[0] / 1,\n    y: viewBox[1] / 1,\n    w: width / viewBox[2],\n    h: height / viewBox[3]\n  }\n}\n\nfunction getPath(path, percent) {\n  var pathEl = is.str(path) ? selectString(path)[0] : path;\n  var p = percent || 100;\n  return function(property) {\n    return {\n      property: property,\n      el: pathEl,\n      svg: getParentSvg(pathEl),\n      totalLength: getTotalLength(pathEl) * (p / 100)\n    }\n  }\n}\n\nfunction getPathProgress(path, progress) {\n  function point(offset) {\n    if ( offset === void 0 ) offset = 0;\n\n    var l = progress + offset >= 1 ? progress + offset : 0;\n    return path.el.getPointAtLength(l);\n  }\n  var svg = getParentSvg(path.el, path.svg);\n  var p = point();\n  var p0 = point(-1);\n  var p1 = point(+1);\n  switch (path.property) {\n    case 'x': return (p.x - svg.x) * svg.w;\n    case 'y': return (p.y - svg.y) * svg.h;\n    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n  }\n}\n\n// Decompose value\n\nfunction decomposeValue(val, unit) {\n  // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n  // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n  var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';\n  return {\n    original: value,\n    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],\n    strings: (is.str(val) || unit) ? value.split(rgx) : []\n  }\n}\n\n// Animatables\n\nfunction parseTargets(targets) {\n  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];\n  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });\n}\n\nfunction getAnimatables(targets) {\n  var parsed = parseTargets(targets);\n  return parsed.map(function (t, i) {\n    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };\n  });\n}\n\n// Properties\n\nfunction normalizePropertyTweens(prop, tweenSettings) {\n  var settings = cloneObject(tweenSettings);\n  // Override duration if easing is a spring\n  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }\n  if (is.arr(prop)) {\n    var l = prop.length;\n    var isFromTo = (l === 2 && !is.obj(prop[0]));\n    if (!isFromTo) {\n      // Duration divided by the number of tweens\n      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }\n    } else {\n      // Transform [from, to] values shorthand to a valid tween value\n      prop = {value: prop};\n    }\n  }\n  var propArray = is.arr(prop) ? prop : [prop];\n  return propArray.map(function (v, i) {\n    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};\n    // Default delay value should only be applied to the first tween\n    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }\n    // Default endDelay value should only be applied to the last tween\n    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }\n    return obj;\n  }).map(function (k) { return mergeObjects(k, settings); });\n}\n\n\nfunction flattenKeyframes(keyframes) {\n  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })\n  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);\n  var properties = {};\n  var loop = function ( i ) {\n    var propName = propertyNames[i];\n    properties[propName] = keyframes.map(function (key) {\n      var newKey = {};\n      for (var p in key) {\n        if (is.key(p)) {\n          if (p == propName) { newKey.value = key[p]; }\n        } else {\n          newKey[p] = key[p];\n        }\n      }\n      return newKey;\n    });\n  };\n\n  for (var i = 0; i < propertyNames.length; i++) loop( i );\n  return properties;\n}\n\nfunction getProperties(tweenSettings, params) {\n  var properties = [];\n  var keyframes = params.keyframes;\n  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }\n  for (var p in params) {\n    if (is.key(p)) {\n      properties.push({\n        name: p,\n        tweens: normalizePropertyTweens(params[p], tweenSettings)\n      });\n    }\n  }\n  return properties;\n}\n\n// Tweens\n\nfunction normalizeTweenValues(tween, animatable) {\n  var t = {};\n  for (var p in tween) {\n    var value = getFunctionValue(tween[p], animatable);\n    if (is.arr(value)) {\n      value = value.map(function (v) { return getFunctionValue(v, animatable); });\n      if (value.length === 1) { value = value[0]; }\n    }\n    t[p] = value;\n  }\n  t.duration = parseFloat(t.duration);\n  t.delay = parseFloat(t.delay);\n  return t;\n}\n\nfunction normalizeTweens(prop, animatable) {\n  var previousTween;\n  return prop.tweens.map(function (t) {\n    var tween = normalizeTweenValues(t, animatable);\n    var tweenValue = tween.value;\n    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n    var toUnit = getUnit(to);\n    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n    var previousValue = previousTween ? previousTween.to.original : originalValue;\n    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n    var fromUnit = getUnit(from) || getUnit(originalValue);\n    var unit = toUnit || fromUnit;\n    if (is.und(to)) { to = previousValue; }\n    tween.from = decomposeValue(from, unit);\n    tween.to = decomposeValue(getRelativeValue(to, from), unit);\n    tween.start = previousTween ? previousTween.end : 0;\n    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;\n    tween.easing = parseEasings(tween.easing, tween.duration);\n    tween.isPath = is.pth(tweenValue);\n    tween.isColor = is.col(tween.from.original);\n    if (tween.isColor) { tween.round = 1; }\n    previousTween = tween;\n    return tween;\n  });\n}\n\n// Tween progress\n\nvar setProgressValue = {\n  css: function (t, p, v) { return t.style[p] = v; },\n  attribute: function (t, p, v) { return t.setAttribute(p, v); },\n  object: function (t, p, v) { return t[p] = v; },\n  transform: function (t, p, v, transforms, manual) {\n    transforms.list.set(p, v);\n    if (p === transforms.last || manual) {\n      var str = '';\n      transforms.list.forEach(function (value, prop) { str += prop + \"(\" + value + \") \"; });\n      t.style.transform = str;\n    }\n  }\n};\n\n// Set Value helper\n\nfunction setTargetsValue(targets, properties) {\n  var animatables = getAnimatables(targets);\n  animatables.forEach(function (animatable) {\n    for (var property in properties) {\n      var value = getFunctionValue(properties[property], animatable);\n      var target = animatable.target;\n      var valueUnit = getUnit(value);\n      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n      var unit = valueUnit || getUnit(originalValue);\n      var to = getRelativeValue(validateValue(value, unit), originalValue);\n      var animType = getAnimationType(target, property);\n      setProgressValue[animType](target, property, to, animatable.transforms, true);\n    }\n  });\n}\n\n// Animations\n\nfunction createAnimation(animatable, prop) {\n  var animType = getAnimationType(animatable.target, prop.name);\n  if (animType) {\n    var tweens = normalizeTweens(prop, animatable);\n    var lastTween = tweens[tweens.length - 1];\n    return {\n      type: animType,\n      property: prop.name,\n      animatable: animatable,\n      tweens: tweens,\n      duration: lastTween.end,\n      delay: tweens[0].delay,\n      endDelay: lastTween.endDelay\n    }\n  }\n}\n\nfunction getAnimations(animatables, properties) {\n  return filterArray(flattenArray(animatables.map(function (animatable) {\n    return properties.map(function (prop) {\n      return createAnimation(animatable, prop);\n    });\n  })), function (a) { return !is.und(a); });\n}\n\n// Create Instance\n\nfunction getInstanceTimings(animations, tweenSettings) {\n  var animLength = animations.length;\n  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };\n  var timings = {};\n  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;\n  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;\n  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;\n  return timings;\n}\n\nvar instanceID = 0;\n\nfunction createNewInstance(params) {\n  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n  var properties = getProperties(tweenSettings, params);\n  var animatables = getAnimatables(params.targets);\n  var animations = getAnimations(animatables, properties);\n  var timings = getInstanceTimings(animations, tweenSettings);\n  var id = instanceID;\n  instanceID++;\n  return mergeObjects(instanceSettings, {\n    id: id,\n    children: [],\n    animatables: animatables,\n    animations: animations,\n    duration: timings.duration,\n    delay: timings.delay,\n    endDelay: timings.endDelay\n  });\n}\n\n// Core\n\nvar activeInstances = [];\nvar pausedInstances = [];\nvar raf;\n\nvar engine = (function () {\n  function play() { \n    raf = requestAnimationFrame(step);\n  }\n  function step(t) {\n    var activeInstancesLength = activeInstances.length;\n    if (activeInstancesLength) {\n      var i = 0;\n      while (i < activeInstancesLength) {\n        var activeInstance = activeInstances[i];\n        if (!activeInstance.paused) {\n          activeInstance.tick(t);\n        } else {\n          var instanceIndex = activeInstances.indexOf(activeInstance);\n          if (instanceIndex > -1) {\n            activeInstances.splice(instanceIndex, 1);\n            activeInstancesLength = activeInstances.length;\n          }\n        }\n        i++;\n      }\n      play();\n    } else {\n      raf = cancelAnimationFrame(raf);\n    }\n  }\n  return play;\n})();\n\nfunction handleVisibilityChange() {\n  if (document.hidden) {\n    activeInstances.forEach(function (ins) { return ins.pause(); });\n    pausedInstances = activeInstances.slice(0);\n    anime.running = activeInstances = [];\n  } else {\n    pausedInstances.forEach(function (ins) { return ins.play(); });\n  }\n}\n\nif (typeof document !== 'undefined') {\n  document.addEventListener('visibilitychange', handleVisibilityChange);\n}\n\n// Public Instance\n\nfunction anime(params) {\n  if ( params === void 0 ) params = {};\n\n\n  var startTime = 0, lastTime = 0, now = 0;\n  var children, childrenLength = 0;\n  var resolve = null;\n\n  function makePromise(instance) {\n    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });\n    instance.finished = promise;\n    return promise;\n  }\n\n  var instance = createNewInstance(params);\n  var promise = makePromise(instance);\n\n  function toggleInstanceDirection() {\n    var direction = instance.direction;\n    if (direction !== 'alternate') {\n      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';\n    }\n    instance.reversed = !instance.reversed;\n    children.forEach(function (child) { return child.reversed = instance.reversed; });\n  }\n\n  function adjustTime(time) {\n    return instance.reversed ? instance.duration - time : time;\n  }\n\n  function resetTime() {\n    startTime = 0;\n    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);\n  }\n\n  function seekChild(time, child) {\n    if (child) { child.seek(time - child.timelineOffset); }\n  }\n\n  function syncInstanceChildren(time) {\n    if (!instance.reversePlayback) {\n      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }\n    } else {\n      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }\n    }\n  }\n\n  function setAnimationsProgress(insTime) {\n    var i = 0;\n    var animations = instance.animations;\n    var animationsLength = animations.length;\n    while (i < animationsLength) {\n      var anim = animations[i];\n      var animatable = anim.animatable;\n      var tweens = anim.tweens;\n      var tweenLength = tweens.length - 1;\n      var tween = tweens[tweenLength];\n      // Only check for keyframes if there is more than one tween\n      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }\n      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);\n      var strings = tween.to.strings;\n      var round = tween.round;\n      var numbers = [];\n      var toNumbersLength = tween.to.numbers.length;\n      var progress = (void 0);\n      for (var n = 0; n < toNumbersLength; n++) {\n        var value = (void 0);\n        var toNumber = tween.to.numbers[n];\n        var fromNumber = tween.from.numbers[n] || 0;\n        if (!tween.isPath) {\n          value = fromNumber + (eased * (toNumber - fromNumber));\n        } else {\n          value = getPathProgress(tween.value, eased * toNumber);\n        }\n        if (round) {\n          if (!(tween.isColor && n > 2)) {\n            value = Math.round(value * round) / round;\n          }\n        }\n        numbers.push(value);\n      }\n      // Manual Array.reduce for better performances\n      var stringsLength = strings.length;\n      if (!stringsLength) {\n        progress = numbers[0];\n      } else {\n        progress = strings[0];\n        for (var s = 0; s < stringsLength; s++) {\n          var a = strings[s];\n          var b = strings[s + 1];\n          var n$1 = numbers[s];\n          if (!isNaN(n$1)) {\n            if (!b) {\n              progress += n$1 + ' ';\n            } else {\n              progress += n$1 + b;\n            }\n          }\n        }\n      }\n      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n      anim.currentValue = progress;\n      i++;\n    }\n  }\n\n  function setCallback(cb) {\n    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }\n  }\n\n  function countIteration() {\n    if (instance.remaining && instance.remaining !== true) {\n      instance.remaining--;\n    }\n  }\n\n  function setInstanceProgress(engineTime) {\n    var insDuration = instance.duration;\n    var insDelay = instance.delay;\n    var insEndDelay = insDuration - instance.endDelay;\n    var insTime = adjustTime(engineTime);\n    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);\n    instance.reversePlayback = insTime < instance.currentTime;\n    if (children) { syncInstanceChildren(insTime); }\n    if (!instance.began && instance.currentTime > 0) {\n      instance.began = true;\n      setCallback('begin');\n    }\n    if (!instance.loopBegan && instance.currentTime > 0) {\n      instance.loopBegan = true;\n      setCallback('loopBegin');\n    }\n    if (insTime <= insDelay && instance.currentTime !== 0) {\n      setAnimationsProgress(0);\n    }\n    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {\n      setAnimationsProgress(insDuration);\n    }\n    if (insTime > insDelay && insTime < insEndDelay) {\n      if (!instance.changeBegan) {\n        instance.changeBegan = true;\n        instance.changeCompleted = false;\n        setCallback('changeBegin');\n      }\n      setCallback('change');\n      setAnimationsProgress(insTime);\n    } else {\n      if (instance.changeBegan) {\n        instance.changeCompleted = true;\n        instance.changeBegan = false;\n        setCallback('changeComplete');\n      }\n    }\n    instance.currentTime = minMax(insTime, 0, insDuration);\n    if (instance.began) { setCallback('update'); }\n    if (engineTime >= insDuration) {\n      lastTime = 0;\n      countIteration();\n      if (!instance.remaining) {\n        instance.paused = true;\n        if (!instance.completed) {\n          instance.completed = true;\n          setCallback('loopComplete');\n          setCallback('complete');\n          if (!instance.passThrough && 'Promise' in window) {\n            resolve();\n            promise = makePromise(instance);\n          }\n        }\n      } else {\n        startTime = now;\n        setCallback('loopComplete');\n        instance.loopBegan = false;\n        if (instance.direction === 'alternate') {\n          toggleInstanceDirection();\n        }\n      }\n    }\n  }\n\n  instance.reset = function() {\n    var direction = instance.direction;\n    instance.passThrough = false;\n    instance.currentTime = 0;\n    instance.progress = 0;\n    instance.paused = true;\n    instance.began = false;\n    instance.loopBegan = false;\n    instance.changeBegan = false;\n    instance.completed = false;\n    instance.changeCompleted = false;\n    instance.reversePlayback = false;\n    instance.reversed = direction === 'reverse';\n    instance.remaining = instance.loop;\n    children = instance.children;\n    childrenLength = children.length;\n    for (var i = childrenLength; i--;) { instance.children[i].reset(); }\n    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }\n    setAnimationsProgress(instance.reversed ? instance.duration : 0);\n  };\n\n  // Set Value helper\n\n  instance.set = function(targets, properties) {\n    setTargetsValue(targets, properties);\n    return instance;\n  };\n\n  instance.tick = function(t) {\n    now = t;\n    if (!startTime) { startTime = now; }\n    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);\n  };\n\n  instance.seek = function(time) {\n    setInstanceProgress(adjustTime(time));\n  };\n\n  instance.pause = function() {\n    instance.paused = true;\n    resetTime();\n  };\n\n  instance.play = function() {\n    if (!instance.paused) { return; }\n    if (instance.completed) { instance.reset(); }\n    instance.paused = false;\n    activeInstances.push(instance);\n    resetTime();\n    if (!raf) { engine(); }\n  };\n\n  instance.reverse = function() {\n    toggleInstanceDirection();\n    resetTime();\n  };\n\n  instance.restart = function() {\n    instance.reset();\n    instance.play();\n  };\n\n  instance.reset();\n\n  if (instance.autoplay) { instance.play(); }\n\n  return instance;\n\n}\n\n// Remove targets from animation\n\nfunction removeTargetsFromAnimations(targetsArray, animations) {\n  for (var a = animations.length; a--;) {\n    if (arrayContains(targetsArray, animations[a].animatable.target)) {\n      animations.splice(a, 1);\n    }\n  }\n}\n\nfunction removeTargets(targets) {\n  var targetsArray = parseTargets(targets);\n  for (var i = activeInstances.length; i--;) {\n    var instance = activeInstances[i];\n    var animations = instance.animations;\n    var children = instance.children;\n    removeTargetsFromAnimations(targetsArray, animations);\n    for (var c = children.length; c--;) {\n      var child = children[c];\n      var childAnimations = child.animations;\n      removeTargetsFromAnimations(targetsArray, childAnimations);\n      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }\n    }\n    if (!animations.length && !children.length) { instance.pause(); }\n  }\n}\n\n// Stagger helpers\n\nfunction stagger(val, params) {\n  if ( params === void 0 ) params = {};\n\n  var direction = params.direction || 'normal';\n  var easing = params.easing ? parseEasings(params.easing) : null;\n  var grid = params.grid;\n  var axis = params.axis;\n  var fromIndex = params.from || 0;\n  var fromFirst = fromIndex === 'first';\n  var fromCenter = fromIndex === 'center';\n  var fromLast = fromIndex === 'last';\n  var isRange = is.arr(val);\n  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);\n  var val2 = isRange ? parseFloat(val[1]) : 0;\n  var unit = getUnit(isRange ? val[1] : val) || 0;\n  var start = params.start || 0 + (isRange ? val1 : 0);\n  var values = [];\n  var maxValue = 0;\n  return function (el, i, t) {\n    if (fromFirst) { fromIndex = 0; }\n    if (fromCenter) { fromIndex = (t - 1) / 2; }\n    if (fromLast) { fromIndex = t - 1; }\n    if (!values.length) {\n      for (var index = 0; index < t; index++) {\n        if (!grid) {\n          values.push(Math.abs(fromIndex - index));\n        } else {\n          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;\n          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;\n          var toX = index%grid[0];\n          var toY = Math.floor(index/grid[0]);\n          var distanceX = fromX - toX;\n          var distanceY = fromY - toY;\n          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') { value = -distanceX; }\n          if (axis === 'y') { value = -distanceY; }\n          values.push(value);\n        }\n        maxValue = Math.max.apply(Math, values);\n      }\n      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }\n      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }\n    }\n    var spacing = isRange ? (val2 - val1) / maxValue : val1;\n    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;\n  }\n}\n\n// Timeline\n\nfunction timeline(params) {\n  if ( params === void 0 ) params = {};\n\n  var tl = anime(params);\n  tl.duration = 0;\n  tl.add = function(instanceParams, timelineOffset) {\n    var tlIndex = activeInstances.indexOf(tl);\n    var children = tl.children;\n    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }\n    function passThrough(ins) { ins.passThrough = true; }\n    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }\n    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));\n    insParams.targets = insParams.targets || params.targets;\n    var tlDuration = tl.duration;\n    insParams.autoplay = false;\n    insParams.direction = tl.direction;\n    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);\n    passThrough(tl);\n    tl.seek(insParams.timelineOffset);\n    var ins = anime(insParams);\n    passThrough(ins);\n    children.push(ins);\n    var timings = getInstanceTimings(children, params);\n    tl.delay = timings.delay;\n    tl.endDelay = timings.endDelay;\n    tl.duration = timings.duration;\n    tl.seek(0);\n    tl.reset();\n    if (tl.autoplay) { tl.play(); }\n    return tl;\n  };\n  return tl;\n}\n\nanime.version = '3.1.0';\nanime.speed = 1;\nanime.running = activeInstances;\nanime.remove = removeTargets;\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.path = getPath;\nanime.setDashoffset = setDashoffset;\nanime.stagger = stagger;\nanime.timeline = timeline;\nanime.easing = parseEasings;\nanime.penner = penner;\nanime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };\n\nmodule.exports = anime;\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","if (window.NodeList && !NodeList.prototype.forEach) {\r\n    NodeList.prototype.forEach = function (callback, thisArg) {\r\n        thisArg = thisArg || window;\r\n        for (var i = 0; i < this.length; i++) {\r\n            callback.call(thisArg, this[i], i, this);\r\n        }\r\n    };\r\n}\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvanMvTGF5ZXIuanMiLCJhcHAvanMvUG9wdXAuanMiLCJhcHAvanMvU21vb3RoLmpzIiwiYXBwL2pzL2RhdGEtZnIuanMiLCJhcHAvanMvZGF0YS1ubC5qcyIsImFwcC9qcy9pbmRleC5qcyIsImFwcC9qcy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlbGlzdC1mb3JlYWNoLXBvbHlmaWxsL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztJQ0FNLEs7OztBQUNKLGlCQUFZLEtBQVosRUFBbUIsTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUMsS0FBakMsRUFBd0M7QUFBQTs7QUFDdEMsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssRUFBTCxHQUFVLEtBQUssQ0FBQyxFQUFoQjtBQUNBLFNBQUssT0FBTCxHQUFlLEtBQUssQ0FBQyxnQkFBTixDQUF1QixTQUF2QixDQUFmO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBSyxDQUFDLGdCQUFOLENBQXVCLE1BQXZCLENBQWI7QUFDQSxTQUFLLElBQUw7QUFDRDs7OzsyQkFFTTtBQUFBOztBQUNMLFVBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFQLENBQWtCLG9CQUFsQixDQUFYOztBQUNBLFVBQUksRUFBRSxDQUFDLE9BQVAsRUFBZ0I7QUFDZCxhQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLFVBQUEsQ0FBQyxFQUFJO0FBQ3RCLFVBQUEsQ0FBQyxDQUFDLGdCQUFGLENBQW1CLFlBQW5CLEVBQWlDLFVBQUMsQ0FBRCxFQUFPO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmxGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjbGFzcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGxheWVyLCBjdXJzb3IsIGRhdGEsIHBvcHVwKSB7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5wb3B1cCA9IHBvcHVwO1xuICAgIHRoaXMuaWQgPSBsYXllci5pZDtcbiAgICB0aGlzLmJ1dHRvbnMgPSBsYXllci5xdWVyeVNlbGVjdG9yQWxsKCcuYnV0dG9uJyk7XG4gICAgdGhpcy5wYXRocyA9IGxheWVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BhdGgnKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3QgbXEgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogODAxcHgpJyk7XG4gICAgaWYgKG1xLm1hdGNoZXMpIHtcbiAgICAgIHRoaXMucGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKGUpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICAgIH0pXG4gICAgICAgIHAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIChlKSA9PiB7XG4gICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub3BlblBvcHVwLmJpbmQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnV0dG9ucy5mb3JFYWNoKGJ0biA9PiB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub3BlblBvcHVwLmJpbmQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb3BlblBvcHVwKGUpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhLmZpbHRlcihwZXJzb24gPT4gcGVyc29uLmlkID09PSB0aGlzLmlkKTtcbiAgICB0aGlzLnBvcHVwLnNldChkYXRhWzBdKTtcbiAgICB0aGlzLnBvcHVwLm9wZW4oKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXllcjsiLCJjbGFzcyBQb3B1cCB7XHJcbiAgY29uc3RydWN0b3Iobm9kZSwgY292ZXJMYXllcikge1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMubmFtZSA9IG5vZGUucXVlcnlTZWxlY3RvcignLnBlcnNvbl9fbmFtZScpO1xyXG4gICAgdGhpcy5yYW5rID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcucGVyc29uX19udW1iZXInKTtcclxuICAgIHRoaXMubGlzdCA9IG5vZGUucXVlcnlTZWxlY3RvcignLnBlcnNvbl9fcmFuaycpO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5vZGUucXVlcnlTZWxlY3RvcignLnBvcHVwX19kZXNjcmlwdGlvbicpO1xyXG4gICAgdGhpcy5pbWdTbWFsbCA9IG5vZGUucXVlcnlTZWxlY3RvcignLnBlcnNvbl9faW1nLWNvbnRhaW5lciBpbWcnKTtcclxuICAgIHRoaXMuaW1nQmlnID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcucG9wdXBfX2ltZycpO1xyXG4gICAgdGhpcy5idG5DbG9zZSA9IG5vZGUucXVlcnlTZWxlY3RvcignLnBvcHVwX19jbG9zZScpO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBmYWxzZTtcclxuICAgIHRoaXMuc21vb3RoID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmNvdmVyTGF5ZXIgPSBjb3ZlckxheWVyO1xyXG5cclxuICAgIHRoaXMuYnRuQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgc2V0U21vb3RoKHNtb290aCkge1xyXG4gICAgdGhpcy5zbW9vdGggPSBzbW9vdGg7XHJcbiAgfVxyXG5cclxuICBvcGVuKCkge1xyXG4gICAgdGhpcy5jb3ZlckxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHRydWU7XHJcbiAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xyXG4gICAgY29uc3QgbXEgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogODAxcHgpJyk7XHJcbiAgICBpZiAobXEubWF0Y2hlcykge1xyXG4gICAgICB0aGlzLnNtb290aC5jYW5jZWxBbmltYXRpb25GcmFtZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2xvc2UoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcclxuICAgIHRoaXMuY292ZXJMYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ3Zpc2libGUnO1xyXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ3Zpc2libGUnO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBmYWxzZTtcclxuICAgIGNvbnN0IG1xID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDgwMXB4KScpO1xyXG4gICAgaWYgKG1xLm1hdGNoZXMpIHtcclxuICAgICAgdGhpcy5zbW9vdGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQoZGF0YSkge1xyXG4gICAgdGhpcy5uYW1lLmlubmVySFRNTCA9IGRhdGEubmFtZTtcclxuICAgIHRoaXMucmFuay5pbm5lckhUTUwgPSBkYXRhLnJhbms7XHJcbiAgICB0aGlzLmxpc3QuaW5uZXJIVE1MID0gZGF0YS5saXN0O1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbi5pbm5lckhUTUwgPSBkYXRhLmRlc2NyaXB0aW9uO1xyXG4gICAgdGhpcy5pbWdTbWFsbC5zcmMgPSBkYXRhLmltZ1NtYWxsO1xyXG4gICAgdGhpcy5pbWdCaWcuc3JjID0gZGF0YS5pbWdCaWc7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb3B1cDsiLCJpbXBvcnQgSGFtbW1lciBmcm9tICdoYW1tZXJqcyc7XHJcbmNsYXNzIFNtb290aCB7XHJcbiAgY29uc3RydWN0b3IocG9wdXAsIGxheWVyT2JqZWN0cykge1xyXG4gICAgdGhpcy5iaW5kTWV0aG9kcygpXHJcblxyXG4gICAgdGhpcy5kYXRhID0ge1xyXG4gICAgICBlYXNlOiAwLjEsXHJcbiAgICAgIGN1cnJlbnQ6IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGxhc3Q6IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDBcclxuICAgICAgfSxcclxuICAgICAgZGVsdGE6IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGxhc3RQYW46IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucG9wdXAgPSBwb3B1cDtcclxuICAgIHRoaXMubGF5ZXJPYmplY3RzID0gbGF5ZXJPYmplY3RzO1xyXG5cclxuICAgIC8vIG1vdXNlXHJcbiAgICB0aGlzLm1vdXNlID0ge1xyXG4gICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCAvIDIsXHJcbiAgICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDIsXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jZW50ZXIgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5pbm5lcldpZHRoIC8gMixcclxuICAgICAgeTogd2luZG93LmlubmVySGVpZ2h0IC8gMiArIDI1LFxyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50RXZlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcclxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICBwYWRkaW5nOiAxNTAsXHJcbiAgICAgIG9mZnNldDogNTAsXHJcbiAgICAgIHNwZWVkOiAxMCxcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1hdGggPSB7XHJcbiAgICAgIGxlcnA6IChhLCBiLCBuKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICgxIC0gbikgKiBhICsgbiAqIGJcclxuICAgICAgfSxcclxuICAgICAgbm9ybTogKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZG9tID0ge1xyXG4gICAgICBjb3ZlcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvdmVyLWxheWVyIC5zbW9vdGgtbmF2JyksXHJcbiAgICAgIHNrZXc6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5za2V3JyksXHJcbiAgICAgIGN1cnNvcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmN1cnNvcicpLFxyXG4gICAgICBleWVzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZXllJyksXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yQUYgPSBudWxsXHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICBiaW5kTWV0aG9kcygpIHtcclxuICAgIFsncnVuJywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScsICdjYW5jZWxBbmltYXRpb25GcmFtZScsICdvblBhbiddXHJcbiAgICAgIC5mb3JFYWNoKChmbikgPT4gdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpKVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICB0aGlzLmN1cnJlbnRFdmVudCA9IGV2ZW50O1xyXG4gICAgaWYgKGV2ZW50ICYmICF0aGlzLnBvcHVwLnN0YXR1cykge1xyXG4gICAgICB0aGlzLm1vdXNlID0ge1xyXG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRvbS5jdXJzb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5tb3VzZS54fXB4LCAke3RoaXMubW91c2UueX1weCwgMClgO1xyXG5cclxuICAgICAgdGhpcy5kb20uZXllcy5mb3JFYWNoKChleWUsIGkpID0+IHtcclxuICAgICAgICBleWUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tb3VzZS54fSwgJHt0aGlzLm1vdXNlLnl9KSBzY2FsZSgkezEgLSAoaSAqIDAuMDgpfSlgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jdXJyZW50RXZlbnQgJiYgdGhpcy5wcmV2RXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRhdGEuY3VycmVudC54IC09IHRoaXMuY3VycmVudEV2ZW50LnNjcmVlblggLSB0aGlzLnByZXZFdmVudC5zY3JlZW5YO1xyXG4gICAgICAgIHRoaXMuZGF0YS5jdXJyZW50LnkgLT0gdGhpcy5jdXJyZW50RXZlbnQuc2NyZWVuWSAtIHRoaXMucHJldkV2ZW50LnNjcmVlblk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJ1bigpIHtcclxuICAgIC8vIGlmICh0aGlzLmN1cnJlbnRFdmVudCAmJiB0aGlzLnByZXZFdmVudCkge1xyXG4gICAgLy8gICB0aGlzLmRhdGEuZGVsdGEueCA9IHRoaXMuY3VycmVudEV2ZW50LnNjcmVlblggLSB0aGlzLnByZXZFdmVudC5zY3JlZW5YO1xyXG4gICAgLy8gICB0aGlzLmRhdGEuZGVsdGEueSA9IHRoaXMuY3VycmVudEV2ZW50LnNjcmVlblkgLSB0aGlzLnByZXZFdmVudC5zY3JlZW5ZO1xyXG4gICAgLy8gfVxyXG4gICAgdGhpcy5wcmV2RXZlbnQgPSB0aGlzLmN1cnJlbnRFdmVudDtcclxuXHJcbiAgICBjb25zdCBkaWZmWCA9IHRoaXMuZGF0YS5kZWx0YS54O1xyXG4gICAgY29uc3QgYWNjWCA9IGRpZmZYIC8gdGhpcy5jb25maWcud2lkdGg7XHJcbiAgICBjb25zdCB2ZWxvWCA9ICthY2NYO1xyXG4gICAgY29uc3Qgc2tld1ggPSB2ZWxvWCAqIDExNy41O1xyXG5cclxuICAgIGNvbnN0IGRpZmZZID0gdGhpcy5kYXRhLmRlbHRhLnk7XHJcbiAgICBjb25zdCBhY2NZID0gZGlmZlkgLyB0aGlzLmNvbmZpZy5oZWlnaHQ7XHJcbiAgICBjb25zdCB2ZWxvWSA9ICthY2NZO1xyXG4gICAgY29uc3Qgc2tld1kgPSB2ZWxvWSAqIDEwMDA7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coc2tld1gsIHNrZXdZKTtcclxuICAgIC8vIHRoaXMuZG9tLnNrZXcuc3R5bGUudHJhbnNmb3JtID0gYHNrZXcoJHtza2V3WH1kZWcsICR7LXNrZXdZfWRlZylgO1xyXG5cclxuICAgIC8vIG1vdmUgcGFyZW50XHJcbiAgICB0aGlzLm1vdmVQYXJlbnQoKTtcclxuXHJcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG4gIH1cclxuXHJcbiAgb25QYW4oZSkge1xyXG4gICAgaWYgKGUudHlwZSA9PT0gJ3Bhbm1vdmUnKSB7XHJcbiAgICAgIHRoaXMuZGF0YS5jdXJyZW50LnggPSB0aGlzLmRhdGEubGFzdFBhbi54ICsgZS5kZWx0YVg7XHJcbiAgICAgIHRoaXMuZGF0YS5jdXJyZW50LnkgPSB0aGlzLmRhdGEubGFzdFBhbi55ICsgZS5kZWx0YVk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXllck9iamVjdHMuZm9yRWFjaChsYXllciA9PiB7XHJcbiAgICAgIGxheWVyLmJ1dHRvbnMuZm9yRWFjaChidG4gPT4ge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IGJ0bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgucG93KE1hdGguYWJzKHRoaXMuY2VudGVyLnggLSBwb3MubGVmdCksIDIpICsgTWF0aC5wb3coTWF0aC5hYnModGhpcy5jZW50ZXIueSAtIHBvcy50b3ApLCAyKSk7XHJcbiAgICAgICAgLy8gY29uc3QgZGlzdCA9IE1hdGguaHlwb3QoY2VudGVyLnggLSBwb3MubGVmdCwgY2VudGVyLnkgLSBjZW50ZXIudG9wKTtcclxuICAgICAgICBpZiAoZGlzdCA8IDEyMCkge1xyXG4gICAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGUudHlwZSA9PT0gJ3BhbmVuZCcpIHtcclxuICAgICAgdGhpcy5kYXRhLmxhc3RQYW4ueCA9IHRoaXMuZGF0YS5jdXJyZW50Lng7XHJcbiAgICAgIHRoaXMuZGF0YS5sYXN0UGFuLnkgPSB0aGlzLmRhdGEuY3VycmVudC55O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbW92ZVBhcmVudCgpIHtcclxuICAgIGNvbnN0IG1xID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDgwMXB4KScpO1xyXG4gICAgaWYgKG1xLm1hdGNoZXMpIHtcclxuICAgICAgdGhpcy5kYXRhLmJvcmRlciA9IHRoaXMuZG9tLmNvdmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICBjb25zdCB7IGJvcmRlciB9ID0gdGhpcy5kYXRhO1xyXG4gICAgICBjb25zdCB7IHBhZGRpbmcsIG9mZnNldCwgc3BlZWQgfSA9IHRoaXMuY29uZmlnO1xyXG4gICAgICBpZiAodGhpcy5tb3VzZS54IDwgcGFkZGluZyAmJiBib3JkZXIubGVmdCA8IC1vZmZzZXQpIHsgLy8gbGVmdFxyXG4gICAgICAgIHRoaXMuZGF0YS5sYXN0LnggKz0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnQueCA9IHRoaXMuZGF0YS5sYXN0Lng7XHJcbiAgICAgICAgdGhpcy5kb20uY292ZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5kYXRhLmxhc3QueH1weCwgJHt0aGlzLmRhdGEubGFzdC55fXB4LCAwKWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3VzZS54ID4gd2luZG93LmlubmVyV2lkdGggLSBwYWRkaW5nICYmIGJvcmRlci5yaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoICsgb2Zmc2V0KSB7IC8vIHJpZ2h0XHJcbiAgICAgICAgdGhpcy5kYXRhLmxhc3QueCAtPSBzcGVlZDtcclxuICAgICAgICB0aGlzLmRhdGEuY3VycmVudC54ID0gdGhpcy5kYXRhLmxhc3QueDtcclxuICAgICAgICB0aGlzLmRvbS5jb3Zlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0aGlzLmRhdGEubGFzdC54fXB4LCAke3RoaXMuZGF0YS5sYXN0Lnl9cHgsIDApYDtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdXNlLnkgPCBwYWRkaW5nICYmIGJvcmRlci50b3AgPCAtb2Zmc2V0KSB7IC8vIHRvcFxyXG4gICAgICAgIHRoaXMuZGF0YS5sYXN0LnkgKz0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnQueSA9IHRoaXMuZGF0YS5sYXN0Lnk7XHJcbiAgICAgICAgdGhpcy5kb20uY292ZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5kYXRhLmxhc3QueH1weCwgJHt0aGlzLmRhdGEubGFzdC55fXB4LCAwKWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3VzZS55ID4gd2luZG93LmlubmVySGVpZ2h0IC0gcGFkZGluZyAmJiBib3JkZXIuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0ICsgb2Zmc2V0KSB7IC8vIGJvdHRvbVxyXG4gICAgICAgIHRoaXMuZGF0YS5sYXN0LnkgLT0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnQueSA9IHRoaXMuZGF0YS5sYXN0Lnk7XHJcbiAgICAgICAgdGhpcy5kb20uY292ZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5kYXRhLmxhc3QueH1weCwgJHt0aGlzLmRhdGEubGFzdC55fXB4LCAwKWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdGhpcy5kYXRhLmxhc3QueCA9IHRoaXMubWF0aC5sZXJwKHRoaXMuZGF0YS5sYXN0LngsIHRoaXMuZGF0YS5jdXJyZW50LngsIHRoaXMuZGF0YS5lYXNlKTtcclxuICAgICAgICAvLyB0aGlzLmRhdGEubGFzdC55ID0gdGhpcy5tYXRoLmxlcnAodGhpcy5kYXRhLmxhc3QueSwgdGhpcy5kYXRhLmN1cnJlbnQueSwgdGhpcy5kYXRhLmVhc2UpO1xyXG4gICAgICAgIC8vIHRoaXMuZG9tLmNvdmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RoaXMuZGF0YS5sYXN0Lnh9cHgsICR7dGhpcy5kYXRhLmxhc3QueX1weCwgMClgO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmRhdGEubGFzdC54ID0gdGhpcy5tYXRoLmxlcnAodGhpcy5kYXRhLmxhc3QueCwgdGhpcy5kYXRhLmN1cnJlbnQueCwgdGhpcy5kYXRhLmVhc2UpO1xyXG4gICAgdGhpcy5kYXRhLmxhc3QueSA9IHRoaXMubWF0aC5sZXJwKHRoaXMuZGF0YS5sYXN0LnksIHRoaXMuZGF0YS5jdXJyZW50LnksIHRoaXMuZGF0YS5lYXNlKTtcclxuICAgIHRoaXMuZG9tLmNvdmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RoaXMuZGF0YS5sYXN0Lnh9cHgsICR7dGhpcy5kYXRhLmxhc3QueX1weCwgMClgO1xyXG4gIH1cclxuXHJcbiAgb25Nb2JpbGUoKSB7XHJcbiAgICB0aGlzLmFkZE1vYmlsZUV2ZW50cygpO1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucnVuKTtcclxuICB9XHJcblxyXG4gIG9uKCkge1xyXG4gICAgdGhpcy5hZGRFdmVudHMoKTtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJ1bik7XHJcbiAgfVxyXG5cclxuICBvZmYoKSB7XHJcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKCk7XHJcbiAgfVxyXG5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB7XHJcbiAgICB0aGlzLnJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJ1bik7XHJcbiAgfVxyXG5cclxuICBjYW5jZWxBbmltYXRpb25GcmFtZSgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuckFGKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSgpO1xyXG4gIH1cclxuXHJcbiAgYWRkTW9iaWxlRXZlbnRzKCkge1xyXG4gICAgdGhpcy5tYyA9IG5ldyBIYW1tbWVyLk1hbmFnZXIoZG9jdW1lbnQuYm9keSk7XHJcbiAgICB0aGlzLm1jLmFkZChuZXcgSGFtbW1lci5QYW4oe1xyXG4gICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgIHBvaW50ZXJzOiAwXHJcbiAgICB9KSk7XHJcbiAgICB0aGlzLm1jLm9uKCdwYW5tb3ZlIHBhbmVuZCcsIHRoaXMub25QYW4pO1xyXG4gIH1cclxuXHJcbiAgYWRkRXZlbnRzKCkge1xyXG4gICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSB0aGlzLnRocm90dGxlKChlKSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShlKSwgMjUpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSk7XHJcbiAgfVxyXG5cclxuICB0aHJvdHRsZShmbiwgbXMpIHtcclxuICAgIHZhciB0aW1lLCBsYXN0ID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHQgPSB0aGlzLFxyXG4gICAgICAgIG5vdyA9ICsobmV3IERhdGUpLFxyXG4gICAgICAgIGV4ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICBmbi5hcHBseSh0LCBhKTtcclxuICAgICAgICB9O1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZSk7XHJcbiAgICAgIChub3cgPj0gbGFzdCArIG1zKSA/IGV4ZSgpIDogdGltZSA9IHNldFRpbWVvdXQoZXhlLCBtcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW1vdmVFdmVudHMoKSB7XHJcbiAgICB0aGlzLmRvbS5jb3ZlckxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSwgeyBwYXNzaXZlOiB0cnVlIH0pXHJcbiAgICB0aGlzLmRvbS5jb3ZlckxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lLCB7IHBhc3NpdmU6IHRydWUgfSlcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICAvLyB0aGlzLm9uKCk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFNtb290aDsiLCJleHBvcnQgZGVmYXVsdCBbXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkdSRVRBXCIsXHJcbiAgICBcIm5hbWVcIjogXCJHcmV0YSBUaHVuYmVyZ1wiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgaW50ZXJuYXRpb25hbGVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDEwLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvR1JFVEFfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvR1JFVEFfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkdyZXRhIFRodW5iZXJnIGVzdCB1bmUgbWlsaXRhbnRlIHN1w6lkb2lzZSBwb3VyIGxhIGx1dHRlIGNvbnRyZSBsZSByw6ljaGF1ZmZlbWVudCBjbGltYXRpcXVlLiBFbGxlIHJlw6dvaXQgcGx1c2lldXJzIHByaXggZXQgZGlzdGluY3Rpb25zIHBvdXIgc29uIG1pbGl0YW50aXNtZS5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJBUkFGQVRcIixcclxuICAgIFwibmFtZVwiOiBcIkRKIEFyYWZhdFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgZnJhbmNvcGhvbmVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDksXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9BUkFGQVRfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvQVJBRkFUX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJESiBBcmFmYXQsIGRlIHNvbiB2cmFpIG5vbSBBbmdlIERpZGllciBIb3VvbiwgZXN0IG1vcnQgZCd1biBhY2NpZGVudCBkZSBsYSByb3V0ZSBsZSAxMi8wOC8yMDE5IMOgIEFiaWRqYW4uIElsIGVzdCBjb25zaWTDqXLDqSBjb21tZSBsJ3VuIGRlcyBwbHVzIGdyYW5kcyBjaGFudGV1cnMgZCdBZnJpcXVlIHN1YnNhaGFyaWVubmUuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiS0FSTFwiLFxyXG4gICAgXCJuYW1lXCI6IFwiS2FybCBMYWdlcmZlbGRcIixcclxuICAgIFwibGlzdFwiOiBcIlBlcnNvbm5hbGl0w6lzIGludGVybmF0aW9uYWxlcyBsZXMgcGx1cyByZWNoZXJjaMOpZXNcIixcclxuICAgIFwicmFua1wiOiAyLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvS0FSTF9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9LQVJMX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJLYXJsIE90dG8gTGFnZXJmZWxkLCBuw6kgbGUgMTAvMDkvMTkzMyDDoCBIYW1ib3VyZyBldCBtb3J0IGxlIDE5LzAyLzIwMTkgw6AgTmV1aWxseS1zdXItU2VpbmUsIGVzdCB1biBncmFuZCBjb3V0dXJpZXIgZXQgc3R5bGlzdGUgYWxsZW1hbmQgYXlhbnQgw6l0w6kgbGUgZGlyZWN0ZXVyIGFydGlzdGlxdWUgZGUgbGEgbWFpc29uIENoYW5lbC5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJNQVJJRVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiTWFyaWUgTGFmb3JldFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgZnJhbmNvcGhvbmVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDEsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9NQVJJRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9NQVJJRV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWFyaWUgTGFmb3LDqnQsIG7DqWUgbGUgMDUvMTAvMTkzOSDDoCBTb3VsYWMtc3VyLU1lciBldCBtb3J0ZSBsZSAwMi8xMS8yMDE5IGVuIFN1aXNzZSwgZXN0IHVuZSBjaGFudGV1c2UgZXQgYWN0cmljZSBmcmFuw6dhaXNlLiBFbGxlIGEgam91w6kgZGFucyAzNSBmaWxtcyBldCB2ZW5kdSBwbHVzIGRlIDM1IG1pbGxpb25zIGQnYWxidW1zLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkNBTUVST05cIixcclxuICAgIFwibmFtZVwiOiBcIkNhbWVyb24gQm95Y2VcIixcclxuICAgIFwibGlzdFwiOiBcIlBlcnNvbm5hbGl0w6lzIGludGVybmF0aW9uYWxlcyBsZXMgcGx1cyByZWNoZXJjaMOpZXNcIixcclxuICAgIFwicmFua1wiOiAzLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvQ0FNRVJPTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9DQU1FUk9OX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDYW1lcm9uIEJveWNlIGVzdCB1biBhY3RldXIsIGRhbnNldXIsIGNoYW50ZXVyIGV0IG1hbm5lcXVpbiBhbcOpcmljYWluLCBuw6kgbGUgMjgvMDUvMTk5OSBldCBtb3J0IGxlIDA2LzA3MjAxOSDDoCBMb3MgQW5nZWxlcy4gSWwgZXN0IGNvbm51IHBvdXIgc29uIHLDtGxlIGRhbnMgbGEgdHJpbG9naWUgRGVzY2VuZGFudHMgZGUgV2FsdCBEaXNuZXkuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiTFVLRVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiTHVrZSBQZXJyeVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgaW50ZXJuYXRpb25hbGVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDQsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9MVUtFX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0xVS0VfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkx1a2UgUGVycnkgZXN0IHVuIGFjdGV1ciBldCBwcm9kdWN0ZXVyIGFtw6lyaWNhaW4sIG7DqSBsZSAxMS8xMC8xOTY2IMOgIE1hbnNmaWVsZCBldCBtb3J0IGxlIDA0LzAzLzIwMTkgw6AgQnVyYmFuay4gSWwgZXN0IHJlY29ubnUgcG91ciBzZXMgcsO0bGVzIGRhbnMgbGVzIHPDqXJpZXMgQmV2ZXJseSBIaWxscyA5MDIxMCBvdSBSaXZlcmRhbGUuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiQ0hJUkFDXCIsXHJcbiAgICBcIm5hbWVcIjogXCJKYWNxdWVzIENoaXJhY1wiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgZnJhbmNvcGhvbmVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDMsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9DSElSQUNfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvQ0hJUkFDX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJKYWNxdWVzIENoaXJhYywgbsOpIGxlIDI5LzExLzE5MzIgw6AgUGFyaXMgZXQgbW9ydCBsZSAyNi8wOS8yMDE5IGRhbnMgbGEgbcOqbWUgdmlsbGUsIGVzdCB1biBoYXV0IGZvbmN0aW9ubmFpcmUgZXQgaG9tbWUgZCfDiXRhdCBmcmFuw6dhaXMuIElsIGbDu3QgcHLDqXNpZGVudCBkZSBsYSBSw6lwdWJsaXF1ZSBmcmFuw6dhaXNlIGRlIDE5OTUgw6AgMjAwNy5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJEQVZJRFwiLFxyXG4gICAgXCJuYW1lXCI6IFwiRGF2aWQgR29mZmluXCIsXHJcbiAgICBcImxpc3RcIjogXCJQZXJzb25uYWxpdMOpcyBmcmFuY29waG9uZXMgbGVzIHBsdXMgcmVjaGVyY2jDqWVzXCIsXHJcbiAgICBcInJhbmtcIjogNCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0RBVklEX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0RBVklEX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEYXZpZCBHb2ZmaW4gZXN0IHVuIGpvdWV1ciBkZSB0ZW5uaXMgcHJvZmVzc2lvbm5lbCBiZWxnZS4gSWwgYSByZW1wb3J0w6kgcXVhdHJlIHRvdXJub2lzIGVuIHNpbXBsZSBldCB1biBlbiBkb3VibGUgc3VyIGxlIGNpcmN1aXQgQVRQLiBEYXZpZCBHb2ZmaW4gZXN0IGF1am91cmTigJlodWkgMTFlIGF1IGNsYXNzZW1lbnQgQVRQLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkFOR0VMRVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiQW5nw6hsZVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiUGVyc29ubmFsaXTDqXMgZnJhbmNvcGhvbmVzIGxlcyBwbHVzIHJlY2hlcmNow6llc1wiLFxyXG4gICAgXCJyYW5rXCI6IDcsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9BTkdFTEVfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvQU5HRUxFX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbmfDqGxlIGVzdCB1bmUgYXV0cmljZS1jb21wb3NpdHJpY2UtaW50ZXJwcsOodGUsIGluc3RydW1lbnRpc3RlIGV0IHByb2R1Y3RyaWNlIGJlbGdlLiBTb24gcHJlbWllciBhbGJ1bSwgQnJvbCwgY2VydGlmacOpIGRpc3F1ZSBkZSBkaWFtYW50LCBzJ2VzdCB2ZW5kdSDDoCBwbHVzIGRlIDUwMCAwMDAgZXhlbXBsYWlyZXMuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiTk9UUkVEQU1FXCIsXHJcbiAgICBcIm5hbWVcIjogXCJJbmNlbmRpZSBOb3RyZS1EYW1lIGRlIFBhcmlzXCIsXHJcbiAgICBcImxpc3RcIjogXCJSZWNoZXJjaGVzIGfDqW7DqXJhbGVzXCIsXHJcbiAgICBcInJhbmtcIjogNyxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L05PVFJFREFNRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9OT1RSRURBTUVfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxhIGNhdGjDqWRyYWxlIE5vdHJlLURhbWUgZGUgUGFyaXMgZXN0IGwndW4gZGVzIG1vbnVtZW50cyBsZXMgcGx1cyBlbWJsw6ltYXRpcXVlcyBkZSBQYXJpcy4gTGUgMTUvMDQvMjAxOSwgdW4gdmlvbGVudCBpbmNlbmRpZSBlbmRvbW1hZ2UgZm9ydGVtZW50IGwnw6lkaWZpY2UsIHF1aSBlc3QgZGVwdWlzIGZlcm3DqSBhdSBwdWJsaWMuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiVE9VUlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiVG91ciBkZSBGcmFuY2Ugw6AgQnJ1eGVsbGVzIChFZ2FuIEJlcm5hbCwgdmFpbnF1ZXVyIGR1IFRvdXIpXCIsXHJcbiAgICBcImxpc3RcIjogXCLDiXbDqW5lbWVudHMgbWFycXVhbnRzXCIsXHJcbiAgICBcInJhbmtcIjogMSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L1RPVVJfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvVE9VUl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGUgVG91ciBkZSBGcmFuY2UgMjAxOSBlc3QgbGEgMTA24bWJIMOpZGl0aW9uIGR1IFRvdXIgZGUgRnJhbmNlIGN5Y2xpc3RlLiBMZSBncmFuZCBkw6lwYXJ0IGEgZXUgbGlldSBsZSA2IGp1aWxsZXQgMjAxOSDDoCBCcnV4ZWxsZXMuIENldHRlIGFubsOpZSwgRWdhbiBCZXJuYWwgZXN0IGRldmVudSBsZSBwbHVzIGpldW5lIHZhaW5xdWV1ciBkdSBUb3VyLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIk1FR0hBTlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiQ291cGUgZHUgbW9uZGUgZGUgZm9vdCBmw6ltaW5pbiAoTWVnaGFuIFJhcGlub2UpXCIsXHJcbiAgICBcImxpc3RcIjogXCLDiXbDqW5lbWVudHMgbWFycXVhbnRzXCIsXHJcbiAgICBcInJhbmtcIjogNSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L01FR0hBTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9NRUdIQU5fYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlBvdXIgbGEgaHVpdGnDqG1lIMOpZGl0aW9uIGRlIExhIENvdXBlIGR1IG1vbmRlIGbDqW1pbmluZSBkZSBmb290YmFsbCAyMDE5LCBjJ2VzdCBsJ8OpcXVpcGUgZGVzIMOJdGF0cy1VbmlzIHF1aSByZW1wb3J0ZSBzb24gNGUgdGl0cmUgbW9uZGlhbC4gTWVnYW4gUmFwaW5vZSBlc3QgZMOpc2lnbsOpZSBtZWlsbGV1cmUgam91ZXVzZSBkdSB0b3Vybm9pLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlRPTVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiVG9tIFZhbiBHcmlla2VuXCIsXHJcbiAgICBcImxpc3RcIjogXCJQZXJzb25uYWxpdMOpcyBiZWxnZXMgbGVzIHBsdXMgcmVjaGVyY2jDqWVzXCIsXHJcbiAgICBcInJhbmtcIjogOCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L1RPTV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9UT01fYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvbSBWYW4gR3JpZWtlbiBlc3QgdW4gaG9tbWUgcG9saXRpcXVlIGJlbGdlIGZsYW1hbmQuIElsIGVzdCBsZSBwcsOpc2lkZW50IGR1IFZsYWFtcyBCZWxhbmcgZGVwdWlzIGxlIDE5IG9jdG9icmUgMjAxNC5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJJTlNUQUdSQU1cIixcclxuICAgIFwibmFtZVwiOiBcIkNvbW1lbnQgc3VwcHJpbWVyIHNvbiBjb21wdGUgSW5zdGFncmFtXCIsXHJcbiAgICBcImxpc3RcIjogXCJDb21tZW504oCmID9cIixcclxuICAgIFwicmFua1wiOiAzLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvSU5TVEFHUkFNX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0lOU1RBR1JBTV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ2V0dGUgYW5uw6llLCBub3VzIGF2b25zIG9ic2VydsOpIHVuZSBjcm9pc3NhbmNlIGRlIGxhIHJlY2hlcmNoZSDigJxDb21tZW50IHN1cHByaW1lciBzb24gY29tcHRlIEluc3RhZ3JhbeKAnSBzdXIgR29vZ2xlLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIldFSUdIVFwiLFxyXG4gICAgXCJuYW1lXCI6IFwiQ29tbWVudCBwZXJkcmUgZHUgdmVudHJlL2R1IHBvaWRzXCIsXHJcbiAgICBcImxpc3RcIjogXCJDb21tZW504oCmID9cIixcclxuICAgIFwicmFua1wiOiAyLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvV0VJR0hUX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L1dFSUdIVF9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ2V0dGUgYW5uw6llLCBiZWF1Y291cCBkZSBiZWxnZXMgc2Ugc29udCBpbnF1acOpdMOpcyBkZSBzYXZvaXIgJ2NvbW1lbnQgcGVyZHJlIGR1IHZlbnRyZS9kdSBwb2lkcycgc3VyIEdvb2dsZVwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkVMRUNUSU9OU0JFXCIsXHJcbiAgICBcIm5hbWVcIjogXCJFbGVjdGlvbnMgYmVsZ2VzXCIsXHJcbiAgICBcImxpc3RcIjogXCJDb21tZW50IC4uLj9cIixcclxuICAgIFwicmFua1wiOiAxLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvRUxFQ1RJT05TX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0VMRUNUSU9OU19iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGVzIMOpbGVjdGlvbnMgZsOpZMOpcmFsZXMgYmVsZ2VzIG9udCBldSBsaWV1IGxlIDI2IG1haSAyMDE5IGFmaW4gZCfDqWxpcmUgbGVzIDE1MCBtZW1icmVzIGRlIGxhIENoYW1icmUgZGVzIHJlcHLDqXNlbnRhbnRzIGJlbGdlLiBCZWF1Y291cCBkZSBiZWxnZXMgc2Ugc29udCByZW5zZWlnbsOpcyBzdXIgJ2NvbW1lbnQgdm90ZXInIHN1ciBHb29nbGUuXCIsXHJcbiAgfSxcclxuXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkVMRUNUSU9OU0VVXCIsXHJcbiAgICBcIm5hbWVcIjogXCJFbGVjdGlvbnMgZXVyb3DDqWVubmVzXCIsXHJcbiAgICBcImxpc3RcIjogXCJSZWNoZXJjaGVzIGfDqW7DqXJhbGVzXCIsXHJcbiAgICBcInJhbmtcIjogMTcsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9FTEVDVElPTlNfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvRUxFQ1RJT05TX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJFbGVjdGlvbiBldXJvcMOpZW5uZXM6IExlcyDDqWxlY3Rpb25zIGV1cm9ww6llbm5lcyBkZSAyMDE5IG9udCBldSBsaWV1IGVudHJlIGxlIDIzIGV0IGxlIDI2IG1haSAyMDE5IGRhbnMgbGVzIHZpbmd0LWh1aXQgw4l0YXRzIG1lbWJyZXMgYWZpbiBkJ8OpbGlyZSBsZXMgZMOpcHV0w6lzIGF1IHNlaW4gZHUgUGFybGVtZW50IGV1cm9ww6llbiBwb3VyIHVuIG1hbmRhdCBkZSBjaW5xIGFucy5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJJUEhPTkVcIixcclxuICAgIFwibmFtZVwiOiBcImlQaG9uZSAxMSAoVGltIENvb2spXCIsXHJcbiAgICBcImxpc3RcIjogXCJSZWNoZXJjaGVzIGfDqW7DqXJhbGVzXCIsXHJcbiAgICBcInJhbmtcIjogNixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0lQSE9ORV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy92YWRvdC9JUEhPTkVfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkwnaVBob25lIDExLCBpUGhvbmUgMTEgUHJvIGV0IGlQaG9uZSAxMSBQcm8gTWF4LCBzb250IHRyb2lzIG1vZMOobGVzIGRlIGxhIHRyZWl6acOobWUgZ8OpbsOpcmF0aW9uIGR1IHNtYXJ0cGhvbmUgZGUgbGEgc29jacOpdMOpIEFwcGxlLiBJbHMgb250IMOpdMOpIHByw6lzZW50w6lzIGF1IHB1YmxpYyBsZSAxMCBzZXB0ZW1icmUgMjAxOS5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJCSUxMSUVcIixcclxuICAgIFwibmFtZVwiOiBcIkJpbGxpZSBFaWxpc2hcIixcclxuICAgIFwibGlzdFwiOiBcIlBlcnNvbm5hbGl0w6lzIGludGVybmF0aW9uYWxlcyBsZXMgcGx1cyByZWNoZXJjaMOpZXNcIixcclxuICAgIFwicmFua1wiOiA2LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvQklMTElFX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0JJTExJRV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQmlsbGllIEVpbGlzaCBlc3QgdW5lIGF1dGV1cmUtY29tcG9zaXRyaWNlLWludGVycHLDqHRlIGFtw6lyaWNhaW5lLiBFbiBub3ZlbWJyZSAyMDE5LCBlbGxlIHNvcnQgdW4gc2luZ2xlIHNlIG5vbW1hbnQgRXZlcnl0aGluZyBJIHdhbnRlZCBxdWkgZmFpdCByYXBpZGVtZW50IHNhIHBsYWNlIGRhbnMgbGVzIGNoYW5zb25zIMOgIHN1Y2PDqHMuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiRFVOQ0FOXCIsXHJcbiAgICBcIm5hbWVcIjogXCJFdXJvdmlzaW9uIDIwMTkgKER1bmNhbiBMYXVyZW5jZSlcIixcclxuICAgIFwibGlzdFwiOiBcIsOJdsOpbmVtZW50cyBtYXJxdWFudHNcIixcclxuICAgIFwicmFua1wiOiAzLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvdmFkb3QvRFVOQ0FOX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL3ZhZG90L0RVTkNBTl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTCdFdXJvdmlzaW9uIGVzdCBsZSBncmFuZCBjb25jb3VycyBldXJvcMOpZW4gZGUgbGEgY2hhbnNvbi4gRHVuY2FuIExhdXJlbmNlIGVzdCB1biBhdXRldXItY29tcG9zaXRldXItaW50ZXJwcsOodGUgbsOpZXJsYW5kYWlzIHF1aSByZW1wb3J0ZSBsJ8OpZGl0aW9uIDIwMTkgYXZlYyBsYSBjaGFuc29uIEFyY2FkZS5cIixcclxuICB9XHJcbl07XHJcbiIsImV4cG9ydCBkZWZhdWx0IFtcclxuICB7XHJcbiAgICBcImlkXCI6IFwiV1RGT0NLXCIsXHJcbiAgICBcIm5hbWVcIjogXCJXVEZvY2tcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogMSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1dURk9DS19zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9XVEZPQ0tfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcInd0Rk9DSyBpcyBlZW4gQmVsZ2lzY2hlIG9ubGluZSBzZXJpZSBkaWUgaGV0IHJlaWxlbiBlbiB6ZWlsZW4gdmFuIGVlbiBncm9lcCB0aWVuZXJtZWlzamVzIC1lbiBqb25nZW5zIG9wIGRlIG1pZGRlbGJhcmUgc2Nob29sIHZvbGd0LlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkpVTElFXCIsXHJcbiAgICBcIm5hbWVcIjogXCJKdWxpZSBWYW4gRXNwZW5cIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogMixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0pVTElFX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0pVTElFX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcCA0IG1laSAyMDE5IHZlcmR3ZWVuIDIzLWphcmlnZSBKdWxpZSBWYW4gRXNwZW4uIERlIGRvb2QgdmFuIGRlIGpvbmdlIHR3aW50aWdlciBsZWlkZGUgdG90IGhlZWwgd2F0IHZlcm9udHdhYXJkaWdpbmcsIHdvZWRlIGVuIGdldm9lbCB2YW4gb252ZWlsaWdoZWlkLCBtZXQgcHJvdGVzdCB0ZWdlbiBzZWtzdWVlbCBnZXdlbGQgYWxzIGdldm9sZy4gXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiVE9VUlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiVG91ciBkZSBGcmFuY2Ug4oCYMTlcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogMyxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1RPVVJfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVE9VUl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGUgZWVyc3RlIGV0YXBwZSBzdGFydHRlIG9wIDYganVsaSAyMDE5IGluIEJydXNzZWwgZW4gZWluZGlnZGUgb3AgZGUgQ2hhbXBzLcOJbHlzw6llcyBpbiBQYXJpanMuIEVnYW4gQmVybmFsIGdpbmcgbG9wZW4gbWV0IGRlIGVpbmR6ZWdlLiBcIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJMT1ZFSVNMQU5EXCIsXHJcbiAgICBcIm5hbWVcIjogXCJMb3ZlIElzbGFuZFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgYWxnZW1lZW5cIixcclxuICAgIFwicmFua1wiOiA0LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvTE9WRUlTTEFORF9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9MT1ZFSVNMQU5EX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb3ZlIElzbGFuZCBpcyBlZW4gaW50ZXJuYXRpb25hYWwgVFYtcHJvZ3JhbW1hIHdhYXJpbiAxMCB2cmlqZ2V6ZWxsZW4gaW4gZWVuIGx1eHVldXplIHZpbGxhIG9wIHpvZWsgZ2FhbiBuYWFyIGRlIHdhcmUgbGllZmRlLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlZPVElOR1wiLFxyXG4gICAgXCJuYW1lXCI6IFwiU3RlbXRlc3RcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogNSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1ZPVElOR19zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9WT1RJTkdfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlIHN0ZW10ZXN0IGlzIGVlbiB0b29sIGRpZSB2aWEgdnJhYWcgZW4gYW50d29vcmQgZGUgbWVlc3QgcGFzc2VuZGUgcGFydGlqIHZvb3IgZGUga2llemVyIGluIGJlZWxkIGJyZW5ndC4gXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiSVBIT05FXCIsXHJcbiAgICBcIm5hbWVcIjogXCJpUGhvbmUgMTFcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogNixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0lQSE9ORV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9JUEhPTkVfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wIDEwIHNlcHRlbWJlciAyMDE5IHdlcmRlbiBkZSBuaWV1d3N0ZSBpUGhvbmUgMTEsIGlQaG9uZSAxMSBQcm8gZW4gaVBob25lIDExIFBybyBNYXggdm9vcmdlc3RlbGQgYWFuIGhldCBncm90ZSBwdWJsaWVrIHRlciBvcHZvbGdpbmcgdmFuIGRlIGlQaG9uZSBYUi5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJOT1RSRURBTUVcIixcclxuICAgIFwibmFtZVwiOiBcIk5vdHJlLURhbWUgUGFyaXNcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogNyxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL05PVFJFREFNRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9OT1RSRURBTUVfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlIFBhcmlqc2Uga2F0aGVkcmFhbCBOb3RyZS1EYW1lIHdlcmQgb3AgMTUgYXByaWwgMjAxOSBnZXRyb2ZmZW4gZG9vciBlZW4gdmVyd29lc3RlbmRlIGJyYW5kLiBNaWxqb2VuZW4gd2VyZGVuIGluZ2V6YW1lbGQgb20gZGUgbWVlc3QgYmV6b2NodGUgYmV6aWVuc3dhYXJkaWdoZWlkIHZhbiBQYXJpanMgd2VlciBvcCB0ZSBsYXBwZW4uXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiSlVMRU5cIixcclxuICAgIFwibmFtZVwiOiBcIkp1bGVuXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBhbGdlbWVlblwiLFxyXG4gICAgXCJyYW5rXCI6IDgsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9KVUxFTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9KVUxFTl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3AgMTMgamFudWFyaSB2aWVsIHBldXRlciBKdWxlbiBSb3NlbGzDsyBpbiBlZW4gMTEwIG1ldGVyIGRpZXBlIHB1dCBpbiBNw6FsYWdhIHdhYXJiaWogaGlqIG92ZXJsZWVkIGFhbiB6aWpuIHZlcndvbmRpbmdlbi4gTmEgMTMgZGFnZW4gc2xhYWdkZSBlZW4gcmVkZGluZ3N0ZWFtIGVyIGluIG9tIGRlIGtsZXV0ZXIgdGUgYmVyZWlrZW4uIFwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIldJTUJMRURPTlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiV2ltYmxlZG9uIDIwMTlcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogOSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1dJTUJMRURPTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9XSU1CTEVET05fYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlIDExM2UgZWRpdGllIHZhbiBoZXQgV2ltYmxlZG9uIENoYW1waW9uc2hpcCB3ZXJkIGdlc3BlZWxkIHZhbiAxIHRvdCAxNCBqdWxpIDIwMTkuIERqb2tvdmljIGJsZWVmIG9wIGtvcCwgU3BhbmphYXJkIFJhZmFlbCBOYWRhbCBlaW5kaWdkZSB0d2VlZGUsIFJvZ2VyIEZlZGVyZXIgd2VyZCBkZXJkZS4gXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiRVVST1ZJU0lPTlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiRXVyb3Zpc2lvbiAyMDE5XCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBhbGdlbWVlblwiLFxyXG4gICAgXCJyYW5rXCI6IDExLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvRVVST1ZJU0lPTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9FVVJPVklTSU9OX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcCAxOCBtZWkgMjAxOSB3ZXJkIEV1cm92aXNpb24gZ2VvcmdhbmlzZWVyZCBpbiBFeHBvIFRlbCBBdml2LCBJc3Jhw6tsLiBOZWRlcmxhbmQgc2Nvb3JkZSA0OTIgcHVudGVuIGVuIHdvbiBtZXQgaGV0IG51bW1lciDigJhBcmNhZGXigJkgdmFuIER1bmNhbiBMYXVyZW5jZS5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJBRlJJS0FDVVBcIixcclxuICAgIFwibmFtZVwiOiBcIkFmcmlrYSBDdXAgMjAxOVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgYWxnZW1lZW5cIixcclxuICAgIFwicmFua1wiOiAxMixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0FGUklLQUNVUF9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9BRlJJS0FDVVBfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlZvb3IgZGUgMzJzdGUga2VlciB3ZXJkIGhldCBBZnJpa2FhbnMga2FtcGlvZW5zY2hhcCB2b2V0YmFsIGdlc3BlZWxkLiBUdXNzZW4gMjEganVuaSAyMDE5IGVuIDE5IGp1bGkgZ2F2ZW4gZGUgZGVlbG5lbWVuZGUgbGFuZGVuIGhldCBiZXN0ZSB2YW4gemljaHplbGYuIEFsZ2VyaWplIHdlcmQgZGUgZ3JvdGUgd2lubmFhci5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJNT0JJU0NPUkVcIixcclxuICAgIFwibmFtZVwiOiBcIk1vYmlzY29yZVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgYWxnZW1lZW5cIixcclxuICAgIFwicmFua1wiOiAxMyxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL01PQklTQ09SRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9NT0JJU0NPUkVfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlIE1vYmlzY29yZSBiZXJla2VudCBkZSBhZnN0YW5kIHZhbiBlbGsgYWRyZXMgaW4gVmxhYW5kZXJlbiBuYWFyIHZlcnNjaGlsbGVuZGUgc29vcnRlbiB2b29yemllbmluZ2VuLiBIb2UgaG9nZXIgZGUgc2NvcmUsIGhvZSBsYWdlciBkZSBtb2JpbGl0ZWl0cy0gZW4gbWlsaWV1LWltcGFjdCB2YW4gamUgd29vbnBsYWF0cy5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJWRVJLSUVaSU5HRU5cIixcclxuICAgIFwibmFtZVwiOiBcIlZlcmtpZXppbmdlbiAyNiBtZWlcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGFsZ2VtZWVuXCIsXHJcbiAgICBcInJhbmtcIjogMTcsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9WRVJLSUVaSU5HRU5fc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVkVSS0lFWklOR0VOX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZSBCZWxnaXNjaGUgZmVkZXJhbGUgdmVya2llemluZ2VuIHZhbiAyMDE5IHdlcmRlbiBnZW9yZ2FuaXNlZXJkIG9wIHpvbmRhZyAyNiBtZWkgMjAxOSwgb3AgZGV6ZWxmZGUgZGFnIGFscyBkZSBFdXJvcGVzZSB2ZXJraWV6aW5nZW4gdmFuIDIwMTkgZW4gZGUgdmVya2llemluZ2VuIHZvb3IgZGUgZGVlbHN0YXRlbi5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJQUk9MRUFHVUVcIixcclxuICAgIFwibmFtZVwiOiBcIkp1cGlsZXIgUHJvIExlYWd1ZSAyMDE5XCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBhbGdlbWVlblwiLFxyXG4gICAgXCJyYW5rXCI6IDE4LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvUFJPTEVBR1VFX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1BST0xFQUdVRV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGUgdm9ldGJhbGNvbXBldGl0aWUgdHVzc2VuIDE2IHRlYW1zIHN0YXJ0dGUgZWluZCBqdWxpIGVuIHphbCBlaW5kaWdlbiBpbiBtYWFydCAyMDIwLiBEZSBCZWxnaXNjaGUgY29tcGV0aXRpZSBzdGFydHRlIGluIDE4OTUgZW4gaXMgZGUgb3Vkc3RlIG9wIGhldCBFdXJvcGVzZSB2YXN0ZWxhbmQuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiV0tWUk9VV0VOXCIsXHJcbiAgICBcIm5hbWVcIjogXCJXSyB2b2V0YmFsIHZyb3V3ZW4gMjAxOVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgYWxnZW1lZW5cIixcclxuICAgIFwicmFua1wiOiAyMCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1dLVlJPVVdFTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9XS1ZST1VXRU5fYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkhldCBXSyAyMDE5IGlzIGRlIGFjaHRzdGUgZWRpdGllIHZhbiBoZXQgd2VyZWxka2FtcGlvZW5zY2hhcCB2b2V0YmFsIHZvb3IgdnJvdXdlbi4gQWFuIGhldCB0b2Vybm9vaSBkZWRlbiAyNCBsYW5kZW4gbWVlLiBEZSBlZXJzdGUgd2Vkc3RyaWpkIHdlcmQgZ2VzcGVlbGQgb3AgNyBqdW5pIDIwMTksIGRlIGZpbmFsZSBvcCA3IGp1bGkgMjAxOS5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJDSFJJU1RPUEhFXCIsXHJcbiAgICBcIm5hbWVcIjogXCJDaHJpc3RvcGhlIExhbWJyZWNodFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgQmVsZ2VuXCIsXHJcbiAgICBcInJhbmtcIjogMixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0NIUklTVE9QSEVfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvQ0hSSVNUT1BIRV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmFkaW9wcmVzZW50YXRvciBDaHJpc3RvcGhlIExhbWJyZWNodCBvdmVybGVlZCBvcCA1IG1laSBvcCA0OC1qYXJpZ2UgbGVlZnRpamQgYWFuIGhhcnRmYWxlbi4gRGUgc3RlbSB2YW4gU3R1ZGlvIEJydXNzZWwgbGlldCBlZW4gdnJpZW5kaW4gZW4gZHJpZSBraW5kZXJlbiBuYS5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJQQVVMXCIsXHJcbiAgICBcIm5hbWVcIjogXCJQYXVsIFNldmVyc1wiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgQmVsZ2VuXCIsXHJcbiAgICBcInJhbmtcIjogMyxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1BBVUxfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvUEFVTF9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3AgOSBhcHJpbCAyMDE5IG92ZXJsZWVkIFZsYWFtc2UgY2hhcm1lemFuZ2VyIFBhdWwgU2V2ZXJzLiBIaWogYnJhayBkb29yIG1ldCBoZXQgbnVtbWVyIOKAmElrIGJlbiB2ZXJsaWVmZCBvcCBqb3XigJkgZW4gd2FzIGdla2VuZCB2YW4gaGV0IHByb2dyYW1tYSDigJhUaWVuIG9tIHRlIHppZW7igJkuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiQkpPUkdcIixcclxuICAgIFwibmFtZVwiOiBcIkJqb3JnIExhbWJyZWNodFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgQmVsZ2VuXCIsXHJcbiAgICBcInJhbmtcIjogNCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0JKT1JHX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0JKT1JHX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJCam9yZyBMYW1icmVjaHQsIHdpZWxyZW5uZXIgZW4gw6nDqW4gdmFuIGRlIGdyb290c3RlIGtsaW10YWxlbnRlbiB2YW4gemlqbiBnZW5lcmF0aWUsIG92ZXJsZWVkIG9wIDUgYXVndXN0dXMgMjAxOSBuYSBlZW4gendhcmUgdmFsIGluIGRlIFJvbmRlIHZhbiBQb2xlbi5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJUSEVPXCIsXHJcbiAgICBcIm5hbWVcIjogXCJUaMOpbyBIYXllelwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgQmVsZ2VuXCIsXHJcbiAgICBcInJhbmtcIjogNSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1RIRU9fc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVEhFT19iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQmVsZ2lzY2hlIGJhY2twYWNrZXIgVGjDqW8gSGF5ZXogdmVyZHdlZW4gb3AgMzEgbWVpIDIwMTkgZW4gd2VyZCBoZXQgbGFhdHN0IGdlemllbiBpbiBoZXQgQXVzdHJhbGlzY2hlIGRvcnAgQnlyb24gQmF5LiBEZSB6b2VrdG9jaHQgbmFhciBUaMOpbyBsb29wdCBub2cgc3RlZWRzLlwiLFxyXG4gIH1cclxuICAsXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIldPVVRcIixcclxuICAgIFwibmFtZVwiOiBcIldvdXQgdmFuIEFlcnRcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDYsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9XT1VUX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1dPVVRfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvcGZhdm9yaWV0IFdvdXQgdmFuIEFlcnQga3dhbSB0aWpkZW5zIGRlIFRvdXIgZGUgRnJhbmNlIG9wIDE5IGp1bGkgb25nZWx1a2tpZyB0ZW4gdmFsIG5hIGVlbiBoYXBlcmluZyBtZXQgZGUgd2VnYWZzbHVpdGluZy4gV291dCBob29wdCBvbSBzbmVsIHppam4gY29tZWJhY2sgdGUgbWFrZW4uXCIsXHJcbiAgfVxyXG4gICxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiRkxPUlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiRmxvciBEZWNsZWlyXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBCZWxnZW5cIixcclxuICAgIFwicmFua1wiOiA3LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvRkxPUl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9GTE9SX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGbG9yLCB6b29uIHZhbiBKYW4gRGVjbGVpciwgaXMgZWVuIEJlbGdpc2NoZSBhY3RldXIgZGllIHJlZWRzIHJvbGxlbiB3aXN0IHRlIHZlcnNpZXJlbiBpbiBWb3NzZW5zdHJla2VuIGVuIEdldWIuIEluIDIwMTkgbWFha3RlIGhpaiBvb2sgYWxzIGVlcnN0ZSBEZWNsZWlyIHppam4gaW50cmVkZSBpbiDigJhEZSBTbGltc3RlIE1lbnMgdGVyIFdlcmVsZOKAmS4gIFwiLFxyXG4gIH1cclxuICAsXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIk1BUklFS0VcIixcclxuICAgIFwibmFtZVwiOiBcIk1hcmlla2UgVmVydm9vcnRcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDgsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9NQVJJRUtFX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL01BUklFS0VfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZWxlbWllIGJlb2VmZW5kZSBhdGxldGllaywgemVpbHdhZ2VucmlqZGVuIGVuIHRyaWF0bG9uLiBNYXJpZWtlIG5hbSAyIGtlZXIgZGVlbCBhYW4gZGUgUGFyYWx5bXBpc2NoZSBTcGVsZW4gZW4gd29uIGhpZXJiaWogdGFsIHZhbiBtZWRhaWxsZXMuIE9wIDIyIG9rdG9iZXIgc3RpZXJmIHplIG5hIGVlbiBzdHJpamQgdGVnZW4gZWVuIHNwaWVyemlla3RlLlwiLFxyXG4gIH1cclxuICAsXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlRPTVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiVG9tIHZhbiBHcmlla2VuXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBCZWxnZW5cIixcclxuICAgIFwicmFua1wiOiA5LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVE9NX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1RPTV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVG9tIHZhbiBHcmlla2VuIHdlcmQgbmEgZGUgdmVya2llemluZ2VuIHZhbiAyMDE5IG1ldCBlZW4gbW9uc3RlcnNjb3JlIHZhbiA5Nyw0JSBvcG5pZXV3IHZlcmtvemVuIHRvdCB2b29yeml0dGVyIHZhbiBWbGFhbXMgQmVsYW5nLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlBJQVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiUGlhXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBCZWxnZW5cIixcclxuICAgIFwicmFua1wiOiAxMCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1BJQV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9QSUFfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlBpYSBsaWpkdCBhYW4gZGUgemVsZHphbWUgc3BpZXJ6aWVrdGUgU01BIGVuIGhhZCBoZXQgbGV2ZW5zcmVkZGVuZGUgbWVkaWNpam4gWm9sZ2Vuc21hIG5vZGlnIG9tIGxhbmdlciB0ZSBrdW5uZW4gbGV2ZW4uIEhldCBtZWRpY2lqbiBrb3N0dGUgMSw5IG1pbGpvZW4gZXVyby4gRGl0IGJlZHJhZyB3ZXJkIG9wIDIgZGFnZW4gdGlqZCBpbmdlemFtZWxkIGRvb3IgY3Jvd2RmdW5kaW5nLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkpPS0VcIixcclxuICAgIFwibmFtZVwiOiBcIkpva2UgU2NoYXV2bGllZ2VcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDExLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvSk9LRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9KT0tFX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJKb2tlIFNjaGF1dmxpZWdlIHN0YXB0ZSBiZWdpbiBmZWJydWFyaSAyMDE5IG9wIGFscyBWbGFhbXMgbWluaXN0ZXIgdmFuIE5hdHV1ciwgTGFuZGJvdXcgZW4gT21nZXZpbmcuIERlIGtvbWVuZGUgNSBqYWFyIGJsaWpmdCB6ZSBwYXJsZW1lbnRzbGlkIHZvb3IgQ0QmVi5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJXSUxMWVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiV2lsbHkgV2lsbHlcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDEyLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvV0lMTFlfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvV0lMTFlfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldpbGx5IExhbWJyZWd0LCBiZWtlbmQgYWxzIFdpbGx5IFdpbGx5IGVuIG9uZGVyIG1lZXIgZGVlbCB2YW4gVGhlIFNjYWJzLCBvdmVybGVlZCBvcCAxMyBmZWJydWFyaSAyMDE5IG5hIGVlbiBzdHJpamQgdGVnZW4ga2Fua2VyLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkRSSUVTXCIsXHJcbiAgICBcIm5hbWVcIjogXCJEcmllcyBWYW4gTGFuZ2VuaG92ZVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgQmVsZ2VuXCIsXHJcbiAgICBcInJhbmtcIjogMTMsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9EUklFU19zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9EUklFU19iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJpZXMgVmFuIExhbmdlbmhvdmUgaXMgZGUgb3ByaWNodGVyIHZhbiBoZXQgZXh0cmVlbXJlY2h0c2UgU2NoaWxkICYgVnJpZW5kZW4uIFZhbiBMYW5nZW5ob3ZlIHRyZWt0IHNpbmRzIDkgamFudWFyaSAyMDE5IGFscyBvbmFmaGFua2VsaWprZSBlZW4gZ2VtZWVuc2NoYXBwZWxpamtlIEthbWVybGlqc3QgbWV0IFZsYWFtcyBCZWxhbmcuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiQVNUUklEXCIsXHJcbiAgICBcIm5hbWVcIjogXCJBc3RyaWQgU3RvY2ttYW5cIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDE0LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvQVNUUklEX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0FTVFJJRF9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQXN0cmlkIFN0b2NrbWFuIGlzIGVlbiAzMi1qYXJpZ2UgQmVsZ2lzY2hlIHNvcHJhYW4gbWV0IGludGVybmF0aW9uYWxlIGJla2VuZGhlaWQuIEluIGhldCBzZWl6b2VuIHZhbiAyMDE5IG5hbSB6ZSBtZXQgc3VjY2VzIGRlZWwgYWFuIERlIFNsaW1zdGUgTWVucyB0ZXIgV2VyZWxkLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkRBVklEXCIsXHJcbiAgICBcIm5hbWVcIjogXCJEYXZpZCBHb2ZmaW5cIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIEJlbGdlblwiLFxyXG4gICAgXCJyYW5rXCI6IDE1LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvREFWSURfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvREFWSURfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRhdmlkIEdvZmZpbiBpcyBlZW4gcHJvZmVzc2lvbmVsZSBCZWxnaXNjaGUgdGVubmlzc3BlbGVyIGVuIHNsdWl0IGhldCBzZWl6b2VuIHZhbiAyMDE5IGFmIG9wIGRlIDExZSBwbGFhdHMgb3AgQVRQIHJhbmtpbmcuIFwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIktBUkxcIixcclxuICAgIFwibmFtZVwiOiBcIkthcmwgTGFnZXJmZWxkXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBhbGdlbWVlblwiLFxyXG4gICAgXCJyYW5rXCI6IDEwLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvS0FSTF9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9LQVJMX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJLYXJsIE90dG8gTGFnZXJmZWxkLCBnZWJvcmVuIG9wIDEwLzA5LzE5MzMgaW4gSGFtYnVyZywgc3RpZXJmIG9wIDE5LzAyLzIwMTkgaW4gTmV1aWxseS1zdXItU2VpbmUuIEthcmwgd2FzIGVlbiBncm90ZSBEdWl0c2UgbW9kZW9udHdlcnBlciBlbiBzdHlsaXN0IGVuIGFydGlzdGllayBkaXJlY3RldXIgdmFuIENoYW5lbC5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJORVlNQVJcIixcclxuICAgIFwibmFtZVwiOiBcIk5leW1hclwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgaW50ZXJuYXRpb25hYWxcIixcclxuICAgIFwicmFua1wiOiA1LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvTkVZTUFSX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL05FWU1BUl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTmV5bWFyLCBzcGVsZXIgdmFuIFBhcmlzIFNhaW50LUdlcm1haW4sIGxlZWQgaGV0IGFmZ2Vsb3BlbiBzZWl6b2VuIGFhbiB2ZXJzY2hpbGxlbmRlIGJsZXNzdXJlcy4gRWVyZGVyIHdlcmQgZWVuIGNvbnRyYWN0dmVybGVuZ2luZyBiaWogUFNHIGFhbmdlYm9kZW4sIG1hYXIgZGllIGxpZXQgTmV5bWFyIHZvb3Jsb3BpZyBsaW5rcyBsaWdnZW4uXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiQklMTElFXCIsXHJcbiAgICBcIm5hbWVcIjogXCJCaWxsaWUgRWlsaXNoXCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBpbnRlcm5hdGlvbmFhbFwiLFxyXG4gICAgXCJyYW5rXCI6IDYsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9CSUxMSUVfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvQklMTElFX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJCaWxsaWUgRWlsaXNoIGlzIGVlbiBBbWVyaWthYW5zZSBzaW5nZXItc29uZ3dyaXRlci4gQmVnaW4gMjAxOSBzY29vcmRlIHplIGVlbiBtb25zdGVyaGl0IGluIG9ucyBsYW5kIG1ldCDigJhCYWQgR3V54oCZLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkdSRVRBXCIsXHJcbiAgICBcIm5hbWVcIjogXCJHcmV0YSBUaHVuYmVyZ1wiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgaW50ZXJuYXRpb25hYWxcIixcclxuICAgIFwicmFua1wiOiAxMCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0dSRVRBX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0dSRVRBX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJHcmV0YSBUaHVuYmVyZyBpcyBlZW4gWndlZWRzZSBhY3RpdmlzdGUgdm9vciBkZSBzdHJpamQgdGVnZW4gZGUgb3B3YXJtaW5nIHZhbiBkZSBhYXJkZS4gWmUgb250dmluZyB2ZXJzY2hpbGxlbmRlIHByaWp6ZW4gZW4gb25kZXJzY2hlaWRpbmdlbiB2b29yIGhhYXIgYWN0aXZpc21lLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlJBTUFEQU5cIixcclxuICAgIFwibmFtZVwiOiBcIlJhbWFkYW4gMjAxOVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgZXZlbmVtZW50ZW5cIixcclxuICAgIFwicmFua1wiOiA3LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvUkFNQURBTl9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9SQU1BREFOX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZSByYW1hZGFuIGlzIGRlIG5lZ2VuZGUgbWFhbmQgb3AgZGUgSXNsYW1pdGlzY2hlIGthbGVuZGVyIGVuIGlzIGRlIGphYXJsaWprc2UgcGVyaW9kZSB3YWFyaW4gbW9zbGltcyB2YXN0ZW4uXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiVk9USU5HXCIsXHJcbiAgICBcIm5hbWVcIjogXCJIb2Ugc3RlbW1lbiBvcCAyNiBtZWlcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGhvZT9cIixcclxuICAgIFwicmFua1wiOiAxLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVk9USU5HX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1ZPVElOR19iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT20gb25zIG9wdGltYWFsIHZvb3IgdGUgYmVyZWlkZW4gdm9vciBkZSB2ZXJraWV6aW5nZW4gdmFuIDIwMTksIHpvY2h0ZW4gd2UgbWFzc2FhbCBuYWFyIGRlIHdpanplIHZhbiBoZXQgc3RlbW1lbi5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJLSVBcIixcclxuICAgIFwibmFtZVwiOiBcIkhvZSBvdWQgd29yZHQgZWVuIGtpcFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgaG9lP1wiLFxyXG4gICAgXCJyYW5rXCI6IDIsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9LSVBfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvS0lQX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbiAyMDE5IHdhcmVuIHZlZWwgbWVuc2VuIGluIEJlbGdpw6sgbmlldXdzZ2llcmlnIG5hYXIgZGUgbWF4aW11bWxlZWZ0aWpkIHZhbiBlZW4ga2lwLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlVTVElNRVwiLFxyXG4gICAgXCJuYW1lXCI6IFwiSG9lIGxhYXQgaXMgaGV0IGluIEFtZXJpa2FcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGhvZT9cIixcclxuICAgIFwicmFua1wiOiAzLFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVVNUSU1FX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1VTVElNRV9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWwgaGFuZ3QgaGV0IGFmIHZhbiB2ZXJzY2hpbGxlbmRlIHRpamR6b25lcywgdG9jaCB3YXMgZGUgdnJhYWcgbmFhciBoZXQgdGlqZHN0aXAgaW4gQW1lcmlrYSBlcmcgZ3Jvb3QuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiVklTVU1cIixcclxuICAgIFwibmFtZVwiOiBcIkhvZSB6aXQgaGV0IG1ldCBtaWpuIHZpc3VtYWFudnJhYWdcIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGhvZT9cIixcclxuICAgIFwicmFua1wiOiA0LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVklTVU1fc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVklTVU1fYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkVlbiBhYW56aWVubGlqayBhYW50YWwgcGVyc29uZW4gaW4gQmVsZ2nDqyB6b2NodCBpbiAyMDE5IG5hYXIgaGV0IHZlcmxvb3AgdmFuIGh1biB2aXN1bWFhbnZyYWFnLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIldFSUdIVFwiLFxyXG4gICAgXCJuYW1lXCI6IFwiSG9lIHNuZWwgYWZ2YWxsZW5cIixcclxuICAgIFwibGlzdFwiOiBcIlRyZW5kaW5nIGhvZT9cIixcclxuICAgIFwicmFua1wiOiA1LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvV0VJR0hUX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1dFSUdIVF9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGUgem9la3RvY2h0IHZpYSBHb29nbGUgbmFhciBkZSBzbmVsc3RlIG1hbmllciB2YW4gYWZ2YWxsZW4gd2FzIGVyZyBwb3B1bGFpciBpbiAyMDE5LlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkNPTkZFREVSQUxJU01FXCIsXHJcbiAgICBcIm5hbWVcIjogXCJXYXQgaXMgY29uZmVkZXJhbGlzbWU/XCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyB3YXQgaXM/XCIsXHJcbiAgICBcInJhbmtcIjogMixcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0NPTkZFREVSQUxJU01FX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0NPTkZFREVSQUxJU01FX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZSBiZXRla2VuaXMgdmFuIGNvbmZlZGVyYWxpc21lIHdlcmQgdmlhIEdvb2dsZSBlZW4gdmVlbGdlem9jaHQgb25kZXJ3ZXJwLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIkxFR0lPTkVMTEFcIixcclxuICAgIFwibmFtZVwiOiBcIldhdCBpcyBsZWdpb25lbGxhP1wiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgd2F0IGlzP1wiLFxyXG4gICAgXCJyYW5rXCI6IDMsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9MRUdJT05FTExBX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0xFR0lPTkVMTEFfYmlnLnBuZ1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkluIDIwMTkgem9jaHRlbiB3ZSBtYXNzYWFsIG5hYXIgbWVlciBpbmZvcm1hdGllIG92ZXIgZGUgYmFjdGVyaWUgbGVnaW9uZWxsYS5cIixcclxuICB9XHJcbiAgLFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJMVUtFXCIsXHJcbiAgICBcIm5hbWVcIjogXCJMdWtlIFBlcnJ5XCIsXHJcbiAgICBcImxpc3RcIjogXCJUcmVuZGluZyBhbGdlbWVlblwiLFxyXG4gICAgXCJyYW5rXCI6IDE1LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvTFVLRV9zbWFsbC5qcGdcIixcclxuICAgIFwiaW1nQmlnXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9MVUtFX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZSBCZXZlcmx5IEhpbGxzLCA5MDIxMC1zdGVyIG92ZXJsZWVkIGluIG1hYXJ0IHRlbiBnZXZvbGdlIHZhbiBlZW4gYmVyb2VydGUuIFZlcmRlciB3ZXJkIEx1a2UgYmVrZW5kIGRvb3IgZGUgaGl0c2VyaWUg4oCYUml2ZXJkYWxl4oCZIGVuIHpvdSBoaWogZWVuIHJvbCBzcGVsZW4gaW4g4oCYT25jZSBVcG9uIGEgVGltZSBpbiBIb2xseXdvb2TigJkuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiU1VOXCIsXHJcbiAgICBcIm5hbWVcIjogXCJIb2Ugd2FybSBpcyBoZXQ/IFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgaG9lP1wiLFxyXG4gICAgXCJyYW5rXCI6IDYsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9TVU5fc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvU1VOX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbiAyMDE5IHdhcmVuIHRhbCB2YW4gcGVyc29uZW4gaW4gQmVsZ2nDqyBiZW5pZXV3ZCBuYWFyIGRlIHRlbXBlcmF0dXVyIHZhbiBkZSBkYWcuXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiQ0FNRVJPTlwiLFxyXG4gICAgXCJuYW1lXCI6IFwiQ2FtZXJvbiBCb3ljZVwiLFxyXG4gICAgXCJsaXN0XCI6IFwiVHJlbmRpbmcgYWxnZW1lZW5cIixcclxuICAgIFwicmFua1wiOiAxNCxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0NBTUVST05fc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvQ0FNRVJPTl9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGUgam9uZ2UgQW1lcmlrYWFuc2UgYWN0ZXVyLCBiZWtlbmQgdmFuIG9uZGVyIGFuZGVyZSBEaXNuZXkgQ2hhbm5lbCwgb3ZlcmxlZWQgYWZnZWxvcGVuIHpvbWVyIGFhbiBkZSBnZXZvbGdlbiB2YW4gZXBpbGVwc2llLiBDYW1lcm9uIHdlcmQgMjAgamFhci5cIixcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRcIjogXCJST01FTFVcIixcclxuICAgIFwibmFtZVwiOiBcIlJvbWVsdSBMdWtha3VcIixcclxuICAgIFwibGlzdFwiOiBcIk1lZXN0IHRyZW5kaW5nIFJvZGUgRHVpdmVsc1wiLFxyXG4gICAgXCJyYW5rXCI6IDEsXHJcbiAgICBcImltZ1NtYWxsXCI6IFwiYXNzZXRzL2ltYWdlcy9tYXJlYy9ST01FTFVfc21hbGwuanBnXCIsXHJcbiAgICBcImltZ0JpZ1wiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvUk9NRUxVX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJSb21lbHUgTHVrYWt1IHdlcmQgaW4gMjAxOSB0b3BzY29yZXIgYWxsZXIgdGlqZGVuIHZvb3IgZGUgUm9kZSBEdWl2ZWxzLCBlbiB2ZXJrYXN0ZSB2YW4gTWFuY2hlc3RlciBVbml0ZWQgbmFhciBJbnRlciBNaWxhYW4uXCIsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImlkXCI6IFwiRVVSTzIwMjBcIixcclxuICAgIFwibmFtZVwiOiBcIkVVUk8gMjAyMFwiLFxyXG4gICAgXCJsaXN0XCI6IFwiTWVlc3QgdHJlbmRpbmcgZXZlbnRzXCIsXHJcbiAgICBcInJhbmtcIjogOSxcclxuICAgIFwiaW1nU21hbGxcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0VVUk8yMDIwX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL0VVUk8yMDIwX2JpZy5wbmdcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZXQgRUsgdm9ldGJhbCBpbiAyMDIwIGRlZWQgQmVsZ2VuIG51IGFsIHdhdGVydGFuZGVuIG5hYXIgd2VrZW4gdm9ldGJhbHBsZXppZXIuIERlIFJvZGUgRHVpdmVscyBiZWhhYWxkZW4gZWVuIHBlcmZlY3QgcmFwcG9ydCB2YW4gMzAvMzAgaW4gZGUga3dhbGlmaWNhdGllLlwiLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZFwiOiBcIlRPTU9SUk9XTEFORFwiLFxyXG4gICAgXCJuYW1lXCI6IFwiVG9tb3Jyb3dsYW5kXCIsXHJcbiAgICBcImxpc3RcIjogXCJNZWVzdCB0cmVuZGluZyBldmVudHNcIixcclxuICAgIFwicmFua1wiOiA2LFxyXG4gICAgXCJpbWdTbWFsbFwiOiBcImFzc2V0cy9pbWFnZXMvbWFyZWMvVE9NT1JST1dMQU5EX3NtYWxsLmpwZ1wiLFxyXG4gICAgXCJpbWdCaWdcIjogXCJhc3NldHMvaW1hZ2VzL21hcmVjL1RPTU9SUk9XTEFORF9iaWcucG5nXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVG9tb3Jyb3dsYW5kLCBoZXQgbXV6aWVrZmVzdGl2YWwgaW4gQm9vbSwgd2FzIG9vayBkaXQgamFhciDDqcOpbiB2YW4gZGUgbWVlc3QgZ2V6b2NodGUgZXZlbnRzIGluIG9ucyBsYW5kLlwiLFxyXG4gIH1cclxuXHJcbl07XHJcbiIsImltcG9ydCAnLi9tYWluJztcbi8vIGltcG9ydCAnLi9tb3JwaCc7IiwiLyoqXHJcbiAqIG1haW4uanNcclxuICogaHR0cHM6Ly95ZWFyaW5zZWFyY2guYmVcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG4gKiBcclxuICogQ29weXJpZ2h0IDIwMTksIFRoZSBSZWZlcmVuY2UgTlYuXHJcbiAqIGh0dHBzOi8vd3d3LnRoZS1yZWZlcmVuY2UuY29tXHJcbiAqL1xyXG5cclxuaW1wb3J0ICdub2RlbGlzdC1mb3JlYWNoLXBvbHlmaWxsJztcclxuXHJcbmltcG9ydCBIYW1tbWVyIGZyb20gJ2hhbW1lcmpzJztcclxuaW1wb3J0IFBvcHVwIGZyb20gJy4vUG9wdXAnO1xyXG5pbXBvcnQgZGF0YU5sIGZyb20gJy4vZGF0YS1ubCc7XHJcbmltcG9ydCBkYXRhRnIgZnJvbSAnLi9kYXRhLWZyJztcclxuaW1wb3J0IGFuaW1lIGZyb20gJ2FuaW1lanMnO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCBTbW9vdGggZnJvbSAnLi9TbW9vdGgnO1xyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG5cdC8vIHZhcmlhYmxlc1xyXG5cdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XHJcblx0Y29uc3QgY292ZXJMYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3Zlci1sYXllcicpO1xyXG5cdGNvbnN0IHNtb290aExheWVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvdmVyLWxheWVyIC5zbW9vdGgtbmF2Jyk7XHJcblx0Y29uc3QgY292ZXJTdmdMYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3Zlci1zdmctbGF5ZXInKTtcclxuXHRjb25zdCBza2V3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNrZXcnKTtcclxuXHRjb25zdCB0b3BMYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50b3AtbGF5ZXInKTtcclxuXHRjb25zdCBob2xlTGF5ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaG9sZS1sYXllcicpO1xyXG5cdC8vY29uc3QgYnRuU3RhcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG9wLWxheWVyIGJ1dHRvbicpO1xyXG5cdGNvbnN0IGJ0blN0YXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmV5ZV9fdGV4dCcpO1xyXG5cdGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3InKTtcclxuXHRsZXQgcG9zID0geyAvLyBwb3NpdGlvbiBvZiBjb3ZlclxyXG5cdFx0eDogMCxcclxuXHRcdHk6IDAsXHJcblx0fVxyXG5cclxuXHRsZXQgY2VudGVyID0ge1xyXG5cdFx0eDogd2luZG93LmlubmVyV2lkdGggLyAyLFxyXG5cdFx0eTogd2luZG93LmlubmVySGVpZ2h0IC8gMiArIDI1LFxyXG5cdH1cclxuXHRsZXQgcG9wdXA7XHJcblx0bGV0IGxheWVyT2JqZWN0cyA9IFtdO1xyXG5cdGxldCBzbW9vdGg7XHJcblx0bGV0IGJvcmRlcnMgPSBzbW9vdGhMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0Ly8gZnVuY3Rpb25zXHJcblx0Y29uc3QgaW5pdCA9ICgpID0+IHtcclxuXHRcdC8vIGNyZWF0ZSBwb3B1cFxyXG5cdFx0cG9wdXAgPSBuZXcgUG9wdXAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBvcHVwJyksIHNtb290aExheWVyKTtcclxuXHRcdGhhbmRsZU1hcmtlcnMoKTtcclxuXHRcdGJ0blN0YXJ0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3RhcnQpO1xyXG5cclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZXRJbml0aWFsQnV0dG9uUG9zKTtcclxuXHRcdHNldEluaXRpYWxCdXR0b25Qb3MoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdCBzZXRJbml0aWFsQnV0dG9uUG9zID0gKCkgPT4ge1xyXG5cdFx0Y29uc3QgbXEgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogODAxcHgpJyk7XHJcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZXllJykuZm9yRWFjaCgoZXllLCBpKSA9PiB7XHJcblx0XHRcdGV5ZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aW5kb3cuaW5uZXJXaWR0aCAvIDJ9LCAke3dpbmRvdy5pbm5lckhlaWdodCAvIDIgKyA1MH0pYCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHN0YXJ0ID0gKGUpID0+IHtcclxuXHRcdHRvcExheWVyLmNsYXNzTGlzdC5hZGQoJ3N0YXJ0ZWQnKTtcclxuXHRcdGhvbGVMYXllci5jbGFzc0xpc3QuYWRkKCdzdGFydGVkJyk7XHJcblx0XHRidG5TdGFydC5jbGFzc0xpc3QuYWRkKCdzdGFydGVkJyk7XHJcblx0XHRzbW9vdGggPSBuZXcgU21vb3RoKHBvcHVwLCBsYXllck9iamVjdHMpO1xyXG5cdFx0cG9wdXAuc2V0U21vb3RoKHNtb290aCk7XHJcblx0XHRjb25zdCBtcSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiA4MDFweCknKTtcclxuXHRcdGlmIChtcS5tYXRjaGVzKSB7XHJcblx0XHRcdGN1cnNvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtlLmNsaWVudFh9cHgsICR7ZS5jbGllbnRZfXB4LCAwKWA7XHJcblx0XHRcdHNtb290aC5vbigpO1xyXG5cdFx0XHRhbmltZSh7XHJcblx0XHRcdFx0dGFyZ2V0czogJyNob2xlIC5leWUnLFxyXG5cdFx0XHRcdHdpZHRoOiAzNTAsXHJcblx0XHRcdFx0aGVpZ2h0OiAzNTAsXHJcblx0XHRcdFx0cng6IDE3NSxcclxuXHRcdFx0XHR4OiAtMTc1LFxyXG5cdFx0XHRcdHk6IC0xNzUsXHJcblx0XHRcdFx0ZHVyYXRpb246IDMwMCxcclxuXHRcdFx0XHRlYXNpbmc6ICdlYXNlSW5PdXRCYWNrJyxcclxuXHRcdFx0fSlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNtb290aC5vbk1vYmlsZSgpO1xyXG5cdFx0XHRhbmltZSh7XHJcblx0XHRcdFx0dGFyZ2V0czogJyNob2xlIC5leWUnLFxyXG5cdFx0XHRcdHdpZHRoOiAzMDAsXHJcblx0XHRcdFx0aGVpZ2h0OiAzMDAsXHJcblx0XHRcdFx0cng6IDE1MCxcclxuXHRcdFx0XHR4OiAtMTUwLFxyXG5cdFx0XHRcdHk6IC0xNTAsXHJcblx0XHRcdFx0ZHVyYXRpb246IDMwMCxcclxuXHRcdFx0XHRlYXNpbmc6ICdlYXNlSW5PdXRCYWNrJyxcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNvbnN0IGhhbmRsZU1hcmtlcnMgPSAoKSA9PiB7XHJcblx0XHRjb25zdCBsYXllcnMgPSBjb3ZlclN2Z0xheWVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5sYXllcicpO1xyXG5cdFx0Y29uc3QgbGFuZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uZ2V0QXR0cmlidXRlKCdsYW5nJyk7XHJcblxyXG5cdFx0aWYgKGxhbmcgPT0gXCJubFwiKSB7XHJcblx0XHRcdGxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcclxuXHRcdFx0XHRsYXllck9iamVjdHMucHVzaChuZXcgTGF5ZXIobGF5ZXIsIGN1cnNvciwgZGF0YU5sLCBwb3B1cCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGlmIChsYW5nID09IFwiZnJcIikge1xyXG5cdFx0XHRsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XHJcblx0XHRcdFx0bGF5ZXJPYmplY3RzLnB1c2gobmV3IExheWVyKGxheWVyLCBjdXJzb3IsIGRhdGFGciwgcG9wdXApKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgaW5pdE1vYmlsZUNvbnRyb2xzID0gKCkgPT4ge1xyXG5cdFx0Ly8gbW9iaWxlIGNvbnRyb2xzXHJcblx0XHRsZXQgbGFzdF94ID0gMDtcclxuXHRcdGxldCBsYXN0X3kgPSAwO1xyXG5cdFx0Y29uc3QgbWMgPSBuZXcgSGFtbW1lci5NYW5hZ2VyKGJvZHkpO1xyXG5cdFx0bWMuYWRkKG5ldyBIYW1tbWVyLlBhbih7XHJcblx0XHRcdHRocmVzaG9sZDogMCxcclxuXHRcdFx0cG9pbnRlcnM6IDBcclxuXHRcdH0pKTtcclxuXHRcdG1jLm9uKCdwYW5tb3ZlIHBhbmVuZCcsIG9uUGFuKTtcclxuXHJcblx0XHRmdW5jdGlvbiBvblBhbihlKSB7XHJcblx0XHRcdGlmIChlLnR5cGUgPT09ICdwYW5tb3ZlJykge1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKGUuZGVsdGFYLCBlLmRlbHRhWSk7XHJcblx0XHRcdFx0cG9zID0ge1xyXG5cdFx0XHRcdFx0eDogbGFzdF94ICsgZS5kZWx0YVgsXHJcblx0XHRcdFx0XHR5OiBsYXN0X3kgKyBlLmRlbHRhWSxcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBgdHJhbnNsYXRlM2QoJHtwb3MueH1weCwgJHtwb3MueX1weCwgMHB4KWA7XHJcblx0XHRcdFx0c21vb3RoTGF5ZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdmFsdWU7XHJcblx0XHRcdFx0c21vb3RoTGF5ZXIuc3R5bGUubW96VHJhbnNmb3JtID0gdmFsdWU7XHJcblx0XHRcdFx0c21vb3RoTGF5ZXIuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxheWVyT2JqZWN0cy5mb3JFYWNoKGxheWVyID0+IHtcclxuXHRcdFx0XHRsYXllci5idXR0b25zLmZvckVhY2goYnRuID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHBvcyA9IGJ0bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoY2VudGVyLnggLSBwb3MubGVmdCksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMoY2VudGVyLnkgLSBwb3MudG9wKSwgMikpO1xyXG5cdFx0XHRcdFx0Ly8gY29uc3QgZGlzdCA9IE1hdGguaHlwb3QoY2VudGVyLnggLSBwb3MubGVmdCwgY2VudGVyLnkgLSBjZW50ZXIudG9wKTtcclxuXHRcdFx0XHRcdGlmIChkaXN0IDwgMTIwKSB7XHJcblx0XHRcdFx0XHRcdGJ0bi5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRidG4uY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmIChlLnR5cGUgPT09ICdwYW5lbmQnKSB7XHJcblx0XHRcdFx0bGFzdF94ID0gcG9zLng7XHJcblx0XHRcdFx0bGFzdF95ID0gcG9zLnk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2cobGFzdF94LCBsYXN0X3kpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGluaXQoKTtcclxufSk7IiwiLypcbiAqIGFuaW1lLmpzIHYzLjEuMFxuICogKGMpIDIwMTkgSnVsaWFuIEdhcm5pZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogYW5pbWVqcy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIERlZmF1bHRzXG5cbnZhciBkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncyA9IHtcbiAgdXBkYXRlOiBudWxsLFxuICBiZWdpbjogbnVsbCxcbiAgbG9vcEJlZ2luOiBudWxsLFxuICBjaGFuZ2VCZWdpbjogbnVsbCxcbiAgY2hhbmdlOiBudWxsLFxuICBjaGFuZ2VDb21wbGV0ZTogbnVsbCxcbiAgbG9vcENvbXBsZXRlOiBudWxsLFxuICBjb21wbGV0ZTogbnVsbCxcbiAgbG9vcDogMSxcbiAgZGlyZWN0aW9uOiAnbm9ybWFsJyxcbiAgYXV0b3BsYXk6IHRydWUsXG4gIHRpbWVsaW5lT2Zmc2V0OiAwXG59O1xuXG52YXIgZGVmYXVsdFR3ZWVuU2V0dGluZ3MgPSB7XG4gIGR1cmF0aW9uOiAxMDAwLFxuICBkZWxheTogMCxcbiAgZW5kRGVsYXk6IDAsXG4gIGVhc2luZzogJ2Vhc2VPdXRFbGFzdGljKDEsIC41KScsXG4gIHJvdW5kOiAwXG59O1xuXG52YXIgdmFsaWRUcmFuc2Zvcm1zID0gWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAndHJhbnNsYXRlWicsICdyb3RhdGUnLCAncm90YXRlWCcsICdyb3RhdGVZJywgJ3JvdGF0ZVonLCAnc2NhbGUnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdzY2FsZVonLCAnc2tldycsICdza2V3WCcsICdza2V3WScsICdwZXJzcGVjdGl2ZSddO1xuXG4vLyBDYWNoaW5nXG5cbnZhciBjYWNoZSA9IHtcbiAgQ1NTOiB7fSxcbiAgc3ByaW5nczoge31cbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIG1pbk1heCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zKHN0ciwgdGV4dCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YodGV4dCkgPiAtMTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcmd1bWVudHMoZnVuYywgYXJncykge1xuICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbn1cblxudmFyIGlzID0ge1xuICBhcnI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpOyB9LFxuICBvYmo6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBzdHJpbmdDb250YWlucyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSksICdPYmplY3QnKTsgfSxcbiAgcHRoOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMub2JqKGEpICYmIGEuaGFzT3duUHJvcGVydHkoJ3RvdGFsTGVuZ3RoJyk7IH0sXG4gIHN2ZzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50OyB9LFxuICBpbnA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudDsgfSxcbiAgZG9tOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ub2RlVHlwZSB8fCBpcy5zdmcoYSk7IH0sXG4gIHN0cjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJzsgfSxcbiAgZm5jOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7IH0sXG4gIHVuZDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAndW5kZWZpbmVkJzsgfSxcbiAgaGV4OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoYSk7IH0sXG4gIHJnYjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9ecmdiLy50ZXN0KGEpOyB9LFxuICBoc2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXmhzbC8udGVzdChhKTsgfSxcbiAgY29sOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGlzLmhleChhKSB8fCBpcy5yZ2IoYSkgfHwgaXMuaHNsKGEpKTsgfSxcbiAga2V5OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmICFkZWZhdWx0VHdlZW5TZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiBhICE9PSAndGFyZ2V0cycgJiYgYSAhPT0gJ2tleWZyYW1lcyc7IH1cbn07XG5cbi8vIEVhc2luZ3NcblxuZnVuY3Rpb24gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSAvXFwoKFteKV0rKVxcKS8uZXhlYyhzdHJpbmcpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcGFyc2VGbG9hdChwKTsgfSkgOiBbXTtcbn1cblxuLy8gU3ByaW5nIHNvbHZlciBpbnNwaXJlZCBieSBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBodHRwczovL3dlYmtpdC5vcmcvZGVtb3Mvc3ByaW5nL3NwcmluZy5qc1xuXG5mdW5jdGlvbiBzcHJpbmcoc3RyaW5nLCBkdXJhdGlvbikge1xuXG4gIHZhciBwYXJhbXMgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKTtcbiAgdmFyIG1hc3MgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1swXSkgPyAxIDogcGFyYW1zWzBdLCAuMSwgMTAwKTtcbiAgdmFyIHN0aWZmbmVzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzFdKSA/IDEwMCA6IHBhcmFtc1sxXSwgLjEsIDEwMCk7XG4gIHZhciBkYW1waW5nID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMl0pID8gMTAgOiBwYXJhbXNbMl0sIC4xLCAxMDApO1xuICB2YXIgdmVsb2NpdHkgPSAgbWluTWF4KGlzLnVuZChwYXJhbXNbM10pID8gMCA6IHBhcmFtc1szXSwgLjEsIDEwMCk7XG4gIHZhciB3MCA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKTtcbiAgdmFyIHpldGEgPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICB2YXIgd2QgPSB6ZXRhIDwgMSA/IHcwICogTWF0aC5zcXJ0KDEgLSB6ZXRhICogemV0YSkgOiAwO1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gemV0YSA8IDEgPyAoemV0YSAqIHcwICsgLXZlbG9jaXR5KSAvIHdkIDogLXZlbG9jaXR5ICsgdzA7XG5cbiAgZnVuY3Rpb24gc29sdmVyKHQpIHtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkdXJhdGlvbiA/IChkdXJhdGlvbiAqIHQpIC8gMTAwMCA6IHQ7XG4gICAgaWYgKHpldGEgPCAxKSB7XG4gICAgICBwcm9ncmVzcyA9IE1hdGguZXhwKC1wcm9ncmVzcyAqIHpldGEgKiB3MCkgKiAoYSAqIE1hdGguY29zKHdkICogcHJvZ3Jlc3MpICsgYiAqIE1hdGguc2luKHdkICogcHJvZ3Jlc3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3Jlc3MgPSAoYSArIGIgKiBwcm9ncmVzcykgKiBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB3MCk7XG4gICAgfVxuICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHsgcmV0dXJuIHQ7IH1cbiAgICByZXR1cm4gMSAtIHByb2dyZXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLnNwcmluZ3Nbc3RyaW5nXTtcbiAgICBpZiAoY2FjaGVkKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgICB2YXIgZnJhbWUgPSAxLzY7XG4gICAgdmFyIGVsYXBzZWQgPSAwO1xuICAgIHZhciByZXN0ID0gMDtcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICBlbGFwc2VkICs9IGZyYW1lO1xuICAgICAgaWYgKHNvbHZlcihlbGFwc2VkKSA9PT0gMSkge1xuICAgICAgICByZXN0Kys7XG4gICAgICAgIGlmIChyZXN0ID49IDE2KSB7IGJyZWFrOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gZWxhcHNlZCAqIGZyYW1lICogMTAwMDtcbiAgICBjYWNoZS5zcHJpbmdzW3N0cmluZ10gPSBkdXJhdGlvbjtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gZHVyYXRpb24gPyBzb2x2ZXIgOiBnZXREdXJhdGlvbjtcblxufVxuXG4vLyBCYXNpYyBzdGVwcyBlYXNpbmcgaW1wbGVtZW50YXRpb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZnIvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG5cbmZ1bmN0aW9uIHN0ZXBzKHN0ZXBzKSB7XG4gIGlmICggc3RlcHMgPT09IHZvaWQgMCApIHN0ZXBzID0gMTA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnJvdW5kKHQgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTsgfTtcbn1cblxuLy8gQmV6aWVyRWFzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZ1xuXG52YXIgYmV6aWVyID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHsgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEMoYUExKSAgICAgIHsgcmV0dXJuIDMuMCAqIGFBMSB9XG5cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHsgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUIH1cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpIH1cblxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkgeyBhQiA9IGN1cnJlbnRUOyB9IGVsc2UgeyBhQSA9IGN1cnJlbnRUOyB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gMC4wMDAwMDAxICYmICsraSA8IDEwKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgeyByZXR1cm4gYUd1ZXNzVDsgfVxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG5cbiAgZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuXG4gICAgaWYgKCEoMCA8PSBtWDEgJiYgbVgxIDw9IDEgJiYgMCA8PSBtWDIgJiYgbVgyIDw9IDEpKSB7IHJldHVybjsgfVxuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuXG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDA7XG4gICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gMC4wMDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7IHJldHVybiB4OyB9XG4gICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKSB7IHJldHVybiB4OyB9XG4gICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGJlemllcjtcblxufSkoKTtcblxudmFyIHBlbm5lciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQmFzZWQgb24galF1ZXJ5IFVJJ3MgaW1wbGVtZW5hdGlvbiBvZiBlYXNpbmcgZXF1YXRpb25zIGZyb20gUm9iZXJ0IFBlbm5lciAoaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZylcblxuICB2YXIgZWFzZXMgPSB7IGxpbmVhcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07IH0gfTtcblxuICB2YXIgZnVuY3Rpb25FYXNpbmdzID0ge1xuICAgIFNpbmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTsgfTsgfSxcbiAgICBDaXJjOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpOyB9OyB9LFxuICAgIEJhY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqICgzICogdCAtIDIpOyB9OyB9LFxuICAgIEJvdW5jZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBwb3cyLCBiID0gNDtcbiAgICAgIHdoaWxlICh0IDwgKCggcG93MiA9IE1hdGgucG93KDIsIC0tYikpIC0gMSkgLyAxMSkge31cbiAgICAgIHJldHVybiAxIC8gTWF0aC5wb3coNCwgMyAtIGIpIC0gNy41NjI1ICogTWF0aC5wb3coKCBwb3cyICogMyAtIDIgKSAvIDIyIC0gdCwgMilcbiAgICB9OyB9LFxuICAgIEVsYXN0aWM6IGZ1bmN0aW9uIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgICAgaWYgKCBhbXBsaXR1ZGUgPT09IHZvaWQgMCApIGFtcGxpdHVkZSA9IDE7XG4gICAgICBpZiAoIHBlcmlvZCA9PT0gdm9pZCAwICkgcGVyaW9kID0gLjU7XG5cbiAgICAgIHZhciBhID0gbWluTWF4KGFtcGxpdHVkZSwgMSwgMTApO1xuICAgICAgdmFyIHAgPSBtaW5NYXgocGVyaW9kLCAuMSwgMik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICh0ID09PSAwIHx8IHQgPT09IDEpID8gdCA6IFxuICAgICAgICAgIC1hICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSAqIE1hdGguc2luKCgoKHQgLSAxKSAtIChwIC8gKE1hdGguUEkgKiAyKSAqIE1hdGguYXNpbigxIC8gYSkpKSAqIChNYXRoLlBJICogMikpIC8gcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBiYXNlRWFzaW5ncyA9IFsnUXVhZCcsICdDdWJpYycsICdRdWFydCcsICdRdWludCcsICdFeHBvJ107XG5cbiAgYmFzZUVhc2luZ3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgIGZ1bmN0aW9uRWFzaW5nc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnBvdyh0LCBpICsgMik7IH07IH07XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGZ1bmN0aW9uRWFzaW5ncykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBlYXNlSW4gPSBmdW5jdGlvbkVhc2luZ3NbbmFtZV07XG4gICAgZWFzZXNbJ2Vhc2VJbicgKyBuYW1lXSA9IGVhc2VJbjtcbiAgICBlYXNlc1snZWFzZU91dCcgKyBuYW1lXSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIGVhc2VJbihhLCBiKSgxIC0gdCk7IH07IH07XG4gICAgZWFzZXNbJ2Vhc2VJbk91dCcgKyBuYW1lXSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IDAuNSA/IGVhc2VJbihhLCBiKSh0ICogMikgLyAyIDogXG4gICAgICAxIC0gZWFzZUluKGEsIGIpKHQgKiAtMiArIDIpIC8gMjsgfTsgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpO1xuICB9XG59XG5cbi8vIFN0cmluZ3NcblxuZnVuY3Rpb24gc2VsZWN0U3RyaW5nKHN0cikge1xuICB0cnkge1xuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc3RyKTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBBcnJheXNcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpIGluIGFycikge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgYXJyKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChpcy5hcnIoYikgPyBmbGF0dGVuQXJyYXkoYikgOiBiKTsgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG8pIHtcbiAgaWYgKGlzLmFycihvKSkgeyByZXR1cm4gbzsgfVxuICBpZiAoaXMuc3RyKG8pKSB7IG8gPSBzZWxlY3RTdHJpbmcobykgfHwgbzsgfVxuICBpZiAobyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IG8gaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbikgeyByZXR1cm4gW10uc2xpY2UuY2FsbChvKTsgfVxuICByZXR1cm4gW29dO1xufVxuXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA9PT0gdmFsOyB9KTtcbn1cblxuLy8gT2JqZWN0c1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChvKSB7XG4gIHZhciBjbG9uZSA9IHt9O1xuICBmb3IgKHZhciBwIGluIG8pIHsgY2xvbmVbcF0gPSBvW3BdOyB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU9iamVjdFByb3BzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMSkgeyBvW3BdID0gbzIuaGFzT3duUHJvcGVydHkocCkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8yKSB7IG9bcF0gPSBpcy51bmQobzFbcF0pID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuLy8gQ29sb3JzXG5cbmZ1bmN0aW9uIHJnYlRvUmdiYShyZ2JWYWx1ZSkge1xuICB2YXIgcmdiID0gL3JnYlxcKChcXGQrLFxccypbXFxkXSssXFxzKltcXGRdKylcXCkvZy5leGVjKHJnYlZhbHVlKTtcbiAgcmV0dXJuIHJnYiA/IChcInJnYmEoXCIgKyAocmdiWzFdKSArIFwiLDEpXCIpIDogcmdiVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGhleFRvUmdiYShoZXhWYWx1ZSkge1xuICB2YXIgcmd4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgdmFyIGhleCA9IGhleFZhbHVlLnJlcGxhY2Uocmd4LCBmdW5jdGlvbiAobSwgciwgZywgYikgeyByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiOyB9ICk7XG4gIHZhciByZ2IgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgdmFyIHIgPSBwYXJzZUludChyZ2JbMV0sIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChyZ2JbMl0sIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChyZ2JbM10sIDE2KTtcbiAgcmV0dXJuIChcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsMSlcIik7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiYShoc2xWYWx1ZSkge1xuICB2YXIgaHNsID0gL2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoaHNsVmFsdWUpIHx8IC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGhzbFZhbHVlKTtcbiAgdmFyIGggPSBwYXJzZUludChoc2xbMV0sIDEwKSAvIDM2MDtcbiAgdmFyIHMgPSBwYXJzZUludChoc2xbMl0sIDEwKSAvIDEwMDtcbiAgdmFyIGwgPSBwYXJzZUludChoc2xbM10sIDEwKSAvIDEwMDtcbiAgdmFyIGEgPSBoc2xbNF0gfHwgMTtcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7IHQgKz0gMTsgfVxuICAgIGlmICh0ID4gMSkgeyB0IC09IDE7IH1cbiAgICBpZiAodCA8IDEvNikgeyByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDsgfVxuICAgIGlmICh0IDwgMS8yKSB7IHJldHVybiBxOyB9XG4gICAgaWYgKHQgPCAyLzMpIHsgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjsgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIHZhciByLCBnLCBiO1xuICBpZiAocyA9PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gIH1cbiAgcmV0dXJuIChcInJnYmEoXCIgKyAociAqIDI1NSkgKyBcIixcIiArIChnICogMjU1KSArIFwiLFwiICsgKGIgKiAyNTUpICsgXCIsXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvUmdiKHZhbCkge1xuICBpZiAoaXMucmdiKHZhbCkpIHsgcmV0dXJuIHJnYlRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oZXgodmFsKSkgeyByZXR1cm4gaGV4VG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhzbCh2YWwpKSB7IHJldHVybiBoc2xUb1JnYmEodmFsKTsgfVxufVxuXG4vLyBVbml0c1xuXG5mdW5jdGlvbiBnZXRVbml0KHZhbCkge1xuICB2YXIgc3BsaXQgPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8oJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyh2YWwpO1xuICBpZiAoc3BsaXQpIHsgcmV0dXJuIHNwbGl0WzFdOyB9XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpIHtcbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAndHJhbnNsYXRlJykgfHwgcHJvcE5hbWUgPT09ICdwZXJzcGVjdGl2ZScpIHsgcmV0dXJuICdweCc7IH1cbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdza2V3JykpIHsgcmV0dXJuICdkZWcnOyB9XG59XG5cbi8vIFZhbHVlc1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbCwgYW5pbWF0YWJsZSkge1xuICBpZiAoIWlzLmZuYyh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgcmV0dXJuIHZhbChhbmltYXRhYmxlLnRhcmdldCwgYW5pbWF0YWJsZS5pZCwgYW5pbWF0YWJsZS50b3RhbCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgcHJvcCkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKHByb3ApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSB7XG4gIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgaWYgKGFycmF5Q29udGFpbnMoW3VuaXQsICdkZWcnLCAncmFkJywgJ3R1cm4nXSwgdmFsdWVVbml0KSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgdmFyIGNhY2hlZCA9IGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdO1xuICBpZiAoIWlzLnVuZChjYWNoZWQpKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgdmFyIGJhc2VsaW5lID0gMTAwO1xuICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcbiAgdmFyIHBhcmVudEVsID0gKGVsLnBhcmVudE5vZGUgJiYgKGVsLnBhcmVudE5vZGUgIT09IGRvY3VtZW50KSkgPyBlbC5wYXJlbnROb2RlIDogZG9jdW1lbnQuYm9keTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgdGVtcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGVtcEVsLnN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyB1bml0O1xuICB2YXIgZmFjdG9yID0gYmFzZWxpbmUgLyB0ZW1wRWwub2Zmc2V0V2lkdGg7XG4gIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gIHZhciBjb252ZXJ0ZWRVbml0ID0gZmFjdG9yICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdID0gY29udmVydGVkVW5pdDtcbiAgcmV0dXJuIGNvbnZlcnRlZFVuaXQ7XG59XG5cbmZ1bmN0aW9uIGdldENTU1ZhbHVlKGVsLCBwcm9wLCB1bml0KSB7XG4gIGlmIChwcm9wIGluIGVsLnN0eWxlKSB7XG4gICAgdmFyIHVwcGVyY2FzZVByb3BOYW1lID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlW3Byb3BdIHx8IGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodXBwZXJjYXNlUHJvcE5hbWUpIHx8ICcwJztcbiAgICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVHlwZShlbCwgcHJvcCkge1xuICBpZiAoaXMuZG9tKGVsKSAmJiAhaXMuaW5wKGVsKSAmJiAoZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB8fCAoaXMuc3ZnKGVsKSAmJiBlbFtwcm9wXSkpKSB7IHJldHVybiAnYXR0cmlidXRlJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiBhcnJheUNvbnRhaW5zKHZhbGlkVHJhbnNmb3JtcywgcHJvcCkpIHsgcmV0dXJuICd0cmFuc2Zvcm0nOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIChwcm9wICE9PSAndHJhbnNmb3JtJyAmJiBnZXRDU1NWYWx1ZShlbCwgcHJvcCkpKSB7IHJldHVybiAnY3NzJzsgfVxuICBpZiAoZWxbcHJvcF0gIT0gbnVsbCkgeyByZXR1cm4gJ29iamVjdCc7IH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpIHtcbiAgaWYgKCFpcy5kb20oZWwpKSB7IHJldHVybjsgfVxuICB2YXIgc3RyID0gZWwuc3R5bGUudHJhbnNmb3JtIHx8ICcnO1xuICB2YXIgcmVnICA9IC8oXFx3KylcXCgoW14pXSopXFwpL2c7XG4gIHZhciB0cmFuc2Zvcm1zID0gbmV3IE1hcCgpO1xuICB2YXIgbTsgd2hpbGUgKG0gPSByZWcuZXhlYyhzdHIpKSB7IHRyYW5zZm9ybXMuc2V0KG1bMV0sIG1bMl0pOyB9XG4gIHJldHVybiB0cmFuc2Zvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1WYWx1ZShlbCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpIHtcbiAgdmFyIGRlZmF1bHRWYWwgPSBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NjYWxlJykgPyAxIDogMCArIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpO1xuICB2YXIgdmFsdWUgPSBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkuZ2V0KHByb3BOYW1lKSB8fCBkZWZhdWx0VmFsO1xuICBpZiAoYW5pbWF0YWJsZSkge1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtcy5saXN0LnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtc1snbGFzdCddID0gcHJvcE5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQsIGFuaW1hdGFibGUpIHtcbiAgc3dpdGNoIChnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcE5hbWUpKSB7XG4gICAgY2FzZSAndHJhbnNmb3JtJzogcmV0dXJuIGdldFRyYW5zZm9ybVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpO1xuICAgIGNhc2UgJ2Nzcyc6IHJldHVybiBnZXRDU1NWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0KTtcbiAgICBjYXNlICdhdHRyaWJ1dGUnOiByZXR1cm4gZ2V0QXR0cmlidXRlKHRhcmdldCwgcHJvcE5hbWUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0YXJnZXRbcHJvcE5hbWVdIHx8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSkge1xuICB2YXIgb3BlcmF0b3IgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKHRvKTtcbiAgaWYgKCFvcGVyYXRvcikgeyByZXR1cm4gdG87IH1cbiAgdmFyIHUgPSBnZXRVbml0KHRvKSB8fCAwO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCh0by5yZXBsYWNlKG9wZXJhdG9yWzBdLCAnJykpO1xuICBzd2l0Y2ggKG9wZXJhdG9yWzBdWzBdKSB7XG4gICAgY2FzZSAnKyc6IHJldHVybiB4ICsgeSArIHU7XG4gICAgY2FzZSAnLSc6IHJldHVybiB4IC0geSArIHU7XG4gICAgY2FzZSAnKic6IHJldHVybiB4ICogeSArIHU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgaWYgKGlzLmNvbCh2YWwpKSB7IHJldHVybiBjb2xvclRvUmdiKHZhbCk7IH1cbiAgaWYgKC9cXHMvZy50ZXN0KHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgaWYgKHVuaXQpIHsgcmV0dXJuIHVuaXRMZXNzICsgdW5pdDsgfVxuICByZXR1cm4gdW5pdExlc3M7XG59XG5cbi8vIGdldFRvdGFsTGVuZ3RoKCkgZXF1aXZhbGVudCBmb3IgY2lyY2xlLCByZWN0LCBwb2x5bGluZSwgcG9seWdvbiBhbmQgbGluZSBzaGFwZXNcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TZWJMYW1ibGEvM2UwNTUwYzQ5NmMyMzY3MDk3NDRcblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2lyY2xlTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBNYXRoLlBJICogMiAqIGdldEF0dHJpYnV0ZShlbCwgJ3InKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdExlbmd0aChlbCkge1xuICByZXR1cm4gKGdldEF0dHJpYnV0ZShlbCwgJ3dpZHRoJykgKiAyKSArIChnZXRBdHRyaWJ1dGUoZWwsICdoZWlnaHQnKSAqIDIpO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDEnKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTEnKX0sIFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MicpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MicpfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICB2YXIgcHJldmlvdXNQb3M7XG4gIGZvciAodmFyIGkgPSAwIDsgaSA8IHBvaW50cy5udW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBvcyA9IHBvaW50cy5nZXRJdGVtKGkpO1xuICAgIGlmIChpID4gMCkgeyB0b3RhbExlbmd0aCArPSBnZXREaXN0YW5jZShwcmV2aW91c1BvcywgY3VycmVudFBvcyk7IH1cbiAgICBwcmV2aW91c1BvcyA9IGN1cnJlbnRQb3M7XG4gIH1cbiAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCkgKyBnZXREaXN0YW5jZShwb2ludHMuZ2V0SXRlbShwb2ludHMubnVtYmVyT2ZJdGVtcyAtIDEpLCBwb2ludHMuZ2V0SXRlbSgwKSk7XG59XG5cbi8vIFBhdGggYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIGdldFRvdGFsTGVuZ3RoKGVsKSB7XG4gIGlmIChlbC5nZXRUb3RhbExlbmd0aCkgeyByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTsgfVxuICBzd2l0Y2goZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnY2lyY2xlJzogcmV0dXJuIGdldENpcmNsZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncmVjdCc6IHJldHVybiBnZXRSZWN0TGVuZ3RoKGVsKTtcbiAgICBjYXNlICdsaW5lJzogcmV0dXJuIGdldExpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlsaW5lJzogcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5Z29uJzogcmV0dXJuIGdldFBvbHlnb25MZW5ndGgoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldERhc2hvZmZzZXQoZWwpIHtcbiAgdmFyIHBhdGhMZW5ndGggPSBnZXRUb3RhbExlbmd0aChlbCk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHBhdGhMZW5ndGgpO1xuICByZXR1cm4gcGF0aExlbmd0aDtcbn1cblxuLy8gTW90aW9uIHBhdGhcblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnRWwoZWwpIHtcbiAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKGlzLnN2ZyhwYXJlbnRFbCkpIHtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcGFyZW50RWw7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2ZyhwYXRoRWwsIHN2Z0RhdGEpIHtcbiAgdmFyIHN2ZyA9IHN2Z0RhdGEgfHwge307XG4gIHZhciBwYXJlbnRTdmdFbCA9IHN2Zy5lbCB8fCBnZXRQYXJlbnRTdmdFbChwYXRoRWwpO1xuICB2YXIgcmVjdCA9IHBhcmVudFN2Z0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdmlld0JveEF0dHIgPSBnZXRBdHRyaWJ1dGUocGFyZW50U3ZnRWwsICd2aWV3Qm94Jyk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHZpZXdCb3ggPSBzdmcudmlld0JveCB8fCAodmlld0JveEF0dHIgPyB2aWV3Qm94QXR0ci5zcGxpdCgnICcpIDogWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgcmV0dXJuIHtcbiAgICBlbDogcGFyZW50U3ZnRWwsXG4gICAgdmlld0JveDogdmlld0JveCxcbiAgICB4OiB2aWV3Qm94WzBdIC8gMSxcbiAgICB5OiB2aWV3Qm94WzFdIC8gMSxcbiAgICB3OiB3aWR0aCAvIHZpZXdCb3hbMl0sXG4gICAgaDogaGVpZ2h0IC8gdmlld0JveFszXVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGgocGF0aCwgcGVyY2VudCkge1xuICB2YXIgcGF0aEVsID0gaXMuc3RyKHBhdGgpID8gc2VsZWN0U3RyaW5nKHBhdGgpWzBdIDogcGF0aDtcbiAgdmFyIHAgPSBwZXJjZW50IHx8IDEwMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIGVsOiBwYXRoRWwsXG4gICAgICBzdmc6IGdldFBhcmVudFN2ZyhwYXRoRWwpLFxuICAgICAgdG90YWxMZW5ndGg6IGdldFRvdGFsTGVuZ3RoKHBhdGhFbCkgKiAocCAvIDEwMClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aFByb2dyZXNzKHBhdGgsIHByb2dyZXNzKSB7XG4gIGZ1bmN0aW9uIHBvaW50KG9mZnNldCkge1xuICAgIGlmICggb2Zmc2V0ID09PSB2b2lkIDAgKSBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGwgPSBwcm9ncmVzcyArIG9mZnNldCA+PSAxID8gcHJvZ3Jlc3MgKyBvZmZzZXQgOiAwO1xuICAgIHJldHVybiBwYXRoLmVsLmdldFBvaW50QXRMZW5ndGgobCk7XG4gIH1cbiAgdmFyIHN2ZyA9IGdldFBhcmVudFN2ZyhwYXRoLmVsLCBwYXRoLnN2Zyk7XG4gIHZhciBwID0gcG9pbnQoKTtcbiAgdmFyIHAwID0gcG9pbnQoLTEpO1xuICB2YXIgcDEgPSBwb2ludCgrMSk7XG4gIHN3aXRjaCAocGF0aC5wcm9wZXJ0eSkge1xuICAgIGNhc2UgJ3gnOiByZXR1cm4gKHAueCAtIHN2Zy54KSAqIHN2Zy53O1xuICAgIGNhc2UgJ3knOiByZXR1cm4gKHAueSAtIHN2Zy55KSAqIHN2Zy5oO1xuICAgIGNhc2UgJ2FuZ2xlJzogcmV0dXJuIE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cbn1cblxuLy8gRGVjb21wb3NlIHZhbHVlXG5cbmZ1bmN0aW9uIGRlY29tcG9zZVZhbHVlKHZhbCwgdW5pdCkge1xuICAvLyBjb25zdCByZ3ggPSAvLT9cXGQqXFwuP1xcZCsvZzsgLy8gaGFuZGxlcyBiYXNpYyBudW1iZXJzXG4gIC8vIGNvbnN0IHJneCA9IC9bKy1dP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vZzsgLy8gaGFuZGxlcyBleHBvbmVudHMgbm90YXRpb25cbiAgdmFyIHJneCA9IC9bKy1dP1xcZCpcXC4/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVZhbHVlKChpcy5wdGgodmFsKSA/IHZhbC50b3RhbExlbmd0aCA6IHZhbCksIHVuaXQpICsgJyc7XG4gIHJldHVybiB7XG4gICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgIG51bWJlcnM6IHZhbHVlLm1hdGNoKHJneCkgPyB2YWx1ZS5tYXRjaChyZ3gpLm1hcChOdW1iZXIpIDogWzBdLFxuICAgIHN0cmluZ3M6IChpcy5zdHIodmFsKSB8fCB1bml0KSA/IHZhbHVlLnNwbGl0KHJneCkgOiBbXVxuICB9XG59XG5cbi8vIEFuaW1hdGFibGVzXG5cbmZ1bmN0aW9uIHBhcnNlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSB0YXJnZXRzID8gKGZsYXR0ZW5BcnJheShpcy5hcnIodGFyZ2V0cykgPyB0YXJnZXRzLm1hcCh0b0FycmF5KSA6IHRvQXJyYXkodGFyZ2V0cykpKSA6IFtdO1xuICByZXR1cm4gZmlsdGVyQXJyYXkodGFyZ2V0c0FycmF5LCBmdW5jdGlvbiAoaXRlbSwgcG9zLCBzZWxmKSB7IHJldHVybiBzZWxmLmluZGV4T2YoaXRlbSkgPT09IHBvczsgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVzKHRhcmdldHMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgcmV0dXJuIHBhcnNlZC5tYXAoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICByZXR1cm4ge3RhcmdldDogdCwgaWQ6IGksIHRvdGFsOiBwYXJzZWQubGVuZ3RoLCB0cmFuc2Zvcm1zOiB7IGxpc3Q6IGdldEVsZW1lbnRUcmFuc2Zvcm1zKHQpIH0gfTtcbiAgfSk7XG59XG5cbi8vIFByb3BlcnRpZXNcblxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHlUd2VlbnMocHJvcCwgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgc2V0dGluZ3MgPSBjbG9uZU9iamVjdCh0d2VlblNldHRpbmdzKTtcbiAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gaWYgZWFzaW5nIGlzIGEgc3ByaW5nXG4gIGlmICgvXnNwcmluZy8udGVzdChzZXR0aW5ncy5lYXNpbmcpKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gc3ByaW5nKHNldHRpbmdzLmVhc2luZyk7IH1cbiAgaWYgKGlzLmFycihwcm9wKSkge1xuICAgIHZhciBsID0gcHJvcC5sZW5ndGg7XG4gICAgdmFyIGlzRnJvbVRvID0gKGwgPT09IDIgJiYgIWlzLm9iaihwcm9wWzBdKSk7XG4gICAgaWYgKCFpc0Zyb21Ubykge1xuICAgICAgLy8gRHVyYXRpb24gZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIHR3ZWVuc1xuICAgICAgaWYgKCFpcy5mbmModHdlZW5TZXR0aW5ncy5kdXJhdGlvbikpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSB0d2VlblNldHRpbmdzLmR1cmF0aW9uIC8gbDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFuc2Zvcm0gW2Zyb20sIHRvXSB2YWx1ZXMgc2hvcnRoYW5kIHRvIGEgdmFsaWQgdHdlZW4gdmFsdWVcbiAgICAgIHByb3AgPSB7dmFsdWU6IHByb3B9O1xuICAgIH1cbiAgfVxuICB2YXIgcHJvcEFycmF5ID0gaXMuYXJyKHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgcmV0dXJuIHByb3BBcnJheS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICB2YXIgb2JqID0gKGlzLm9iaih2KSAmJiAhaXMucHRoKHYpKSA/IHYgOiB7dmFsdWU6IHZ9O1xuICAgIC8vIERlZmF1bHQgZGVsYXkgdmFsdWUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZmlyc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5kZWxheSkpIHsgb2JqLmRlbGF5ID0gIWkgPyB0d2VlblNldHRpbmdzLmRlbGF5IDogMDsgfVxuICAgIC8vIERlZmF1bHQgZW5kRGVsYXkgdmFsdWUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgbGFzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmVuZERlbGF5KSkgeyBvYmouZW5kRGVsYXkgPSBpID09PSBwcm9wQXJyYXkubGVuZ3RoIC0gMSA/IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXkgOiAwOyB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBtZXJnZU9iamVjdHMoaywgc2V0dGluZ3MpOyB9KTtcbn1cblxuXG5mdW5jdGlvbiBmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcykge1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IGZpbHRlckFycmF5KGZsYXR0ZW5BcnJheShrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIE9iamVjdC5rZXlzKGtleSk7IH0pKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIGlzLmtleShwKTsgfSlcbiAgLnJlZHVjZShmdW5jdGlvbiAoYSxiKSB7IGlmIChhLmluZGV4T2YoYikgPCAwKSB7IGEucHVzaChiKTsgfSByZXR1cm4gYTsgfSwgW10pO1xuICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0ga2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbmV3S2V5ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGtleSkge1xuICAgICAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICAgICAgaWYgKHAgPT0gcHJvcE5hbWUpIHsgbmV3S2V5LnZhbHVlID0ga2V5W3BdOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3S2V5W3BdID0ga2V5W3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3S2V5O1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXTtcbiAgdmFyIGtleWZyYW1lcyA9IHBhcmFtcy5rZXlmcmFtZXM7XG4gIGlmIChrZXlmcmFtZXMpIHsgcGFyYW1zID0gbWVyZ2VPYmplY3RzKGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSwgcGFyYW1zKTsgfVxuICBmb3IgKHZhciBwIGluIHBhcmFtcykge1xuICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IHAsXG4gICAgICAgIHR3ZWVuczogbm9ybWFsaXplUHJvcGVydHlUd2VlbnMocGFyYW1zW3BdLCB0d2VlblNldHRpbmdzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG4vLyBUd2VlbnNcblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5WYWx1ZXModHdlZW4sIGFuaW1hdGFibGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiB0d2Vlbikge1xuICAgIHZhciB2YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUodHdlZW5bcF0sIGFuaW1hdGFibGUpO1xuICAgIGlmIChpcy5hcnIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZ2V0RnVuY3Rpb25WYWx1ZSh2LCBhbmltYXRhYmxlKTsgfSk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7IHZhbHVlID0gdmFsdWVbMF07IH1cbiAgICB9XG4gICAgdFtwXSA9IHZhbHVlO1xuICB9XG4gIHQuZHVyYXRpb24gPSBwYXJzZUZsb2F0KHQuZHVyYXRpb24pO1xuICB0LmRlbGF5ID0gcGFyc2VGbG9hdCh0LmRlbGF5KTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKSB7XG4gIHZhciBwcmV2aW91c1R3ZWVuO1xuICByZXR1cm4gcHJvcC50d2VlbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHR3ZWVuID0gbm9ybWFsaXplVHdlZW5WYWx1ZXModCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHR3ZWVuVmFsdWUgPSB0d2Vlbi52YWx1ZTtcbiAgICB2YXIgdG8gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzFdIDogdHdlZW5WYWx1ZTtcbiAgICB2YXIgdG9Vbml0ID0gZ2V0VW5pdCh0byk7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUsIHRvVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi50by5vcmlnaW5hbCA6IG9yaWdpbmFsVmFsdWU7XG4gICAgdmFyIGZyb20gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzBdIDogcHJldmlvdXNWYWx1ZTtcbiAgICB2YXIgZnJvbVVuaXQgPSBnZXRVbml0KGZyb20pIHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgdmFyIHVuaXQgPSB0b1VuaXQgfHwgZnJvbVVuaXQ7XG4gICAgaWYgKGlzLnVuZCh0bykpIHsgdG8gPSBwcmV2aW91c1ZhbHVlOyB9XG4gICAgdHdlZW4uZnJvbSA9IGRlY29tcG9zZVZhbHVlKGZyb20sIHVuaXQpO1xuICAgIHR3ZWVuLnRvID0gZGVjb21wb3NlVmFsdWUoZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSksIHVuaXQpO1xuICAgIHR3ZWVuLnN0YXJ0ID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4uZW5kIDogMDtcbiAgICB0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydCArIHR3ZWVuLmRlbGF5ICsgdHdlZW4uZHVyYXRpb24gKyB0d2Vlbi5lbmREZWxheTtcbiAgICB0d2Vlbi5lYXNpbmcgPSBwYXJzZUVhc2luZ3ModHdlZW4uZWFzaW5nLCB0d2Vlbi5kdXJhdGlvbik7XG4gICAgdHdlZW4uaXNQYXRoID0gaXMucHRoKHR3ZWVuVmFsdWUpO1xuICAgIHR3ZWVuLmlzQ29sb3IgPSBpcy5jb2wodHdlZW4uZnJvbS5vcmlnaW5hbCk7XG4gICAgaWYgKHR3ZWVuLmlzQ29sb3IpIHsgdHdlZW4ucm91bmQgPSAxOyB9XG4gICAgcHJldmlvdXNUd2VlbiA9IHR3ZWVuO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfSk7XG59XG5cbi8vIFR3ZWVuIHByb2dyZXNzXG5cbnZhciBzZXRQcm9ncmVzc1ZhbHVlID0ge1xuICBjc3M6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnN0eWxlW3BdID0gdjsgfSxcbiAgYXR0cmlidXRlOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zZXRBdHRyaWJ1dGUocCwgdik7IH0sXG4gIG9iamVjdDogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHRbcF0gPSB2OyB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh0LCBwLCB2LCB0cmFuc2Zvcm1zLCBtYW51YWwpIHtcbiAgICB0cmFuc2Zvcm1zLmxpc3Quc2V0KHAsIHYpO1xuICAgIGlmIChwID09PSB0cmFuc2Zvcm1zLmxhc3QgfHwgbWFudWFsKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB0cmFuc2Zvcm1zLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIHByb3ApIHsgc3RyICs9IHByb3AgKyBcIihcIiArIHZhbHVlICsgXCIpIFwiOyB9KTtcbiAgICAgIHQuc3R5bGUudHJhbnNmb3JtID0gc3RyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gU2V0IFZhbHVlIGhlbHBlclxuXG5mdW5jdGlvbiBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcykge1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKTtcbiAgYW5pbWF0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUocHJvcGVydGllc1twcm9wZXJ0eV0sIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHRhcmdldCA9IGFuaW1hdGFibGUudGFyZ2V0O1xuICAgICAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdW5pdCA9IHZhbHVlVW5pdCB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIHRvID0gZ2V0UmVsYXRpdmVWYWx1ZSh2YWxpZGF0ZVZhbHVlKHZhbHVlLCB1bml0KSwgb3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltVHlwZV0odGFyZ2V0LCBwcm9wZXJ0eSwgdG8sIGFuaW1hdGFibGUudHJhbnNmb3JtcywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gQW5pbWF0aW9uc1xuXG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb24oYW5pbWF0YWJsZSwgcHJvcCkge1xuICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUpO1xuICBpZiAoYW5pbVR5cGUpIHtcbiAgICB2YXIgdHdlZW5zID0gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpO1xuICAgIHZhciBsYXN0VHdlZW4gPSB0d2VlbnNbdHdlZW5zLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhbmltVHlwZSxcbiAgICAgIHByb3BlcnR5OiBwcm9wLm5hbWUsXG4gICAgICBhbmltYXRhYmxlOiBhbmltYXRhYmxlLFxuICAgICAgdHdlZW5zOiB0d2VlbnMsXG4gICAgICBkdXJhdGlvbjogbGFzdFR3ZWVuLmVuZCxcbiAgICAgIGRlbGF5OiB0d2VlbnNbMF0uZGVsYXksXG4gICAgICBlbmREZWxheTogbGFzdFR3ZWVuLmVuZERlbGF5XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbnMoYW5pbWF0YWJsZXMsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIGZpbHRlckFycmF5KGZsYXR0ZW5BcnJheShhbmltYXRhYmxlcy5tYXAoZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBjcmVhdGVBbmltYXRpb24oYW5pbWF0YWJsZSwgcHJvcCk7XG4gICAgfSk7XG4gIH0pKSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFpcy51bmQoYSk7IH0pO1xufVxuXG4vLyBDcmVhdGUgSW5zdGFuY2VcblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIGFuaW1MZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgdmFyIGdldFRsT2Zmc2V0ID0gZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGFuaW0udGltZWxpbmVPZmZzZXQgPyBhbmltLnRpbWVsaW5lT2Zmc2V0IDogMDsgfTtcbiAgdmFyIHRpbWluZ3MgPSB7fTtcbiAgdGltaW5ncy5kdXJhdGlvbiA9IGFuaW1MZW5ndGggPyBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uOyB9KSkgOiB0d2VlblNldHRpbmdzLmR1cmF0aW9uO1xuICB0aW1pbmdzLmRlbGF5ID0gYW5pbUxlbmd0aCA/IE1hdGgubWluLmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZGVsYXk7XG4gIHRpbWluZ3MuZW5kRGVsYXkgPSBhbmltTGVuZ3RoID8gdGltaW5ncy5kdXJhdGlvbiAtIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb24gLSBhbmltLmVuZERlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmVuZERlbGF5O1xuICByZXR1cm4gdGltaW5ncztcbn1cblxudmFyIGluc3RhbmNlSUQgPSAwO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpIHtcbiAgdmFyIGluc3RhbmNlU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciB0d2VlblNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRUd2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgcHJvcGVydGllcyA9IGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXMocGFyYW1zLnRhcmdldHMpO1xuICB2YXIgYW5pbWF0aW9ucyA9IGdldEFuaW1hdGlvbnMoYW5pbWF0YWJsZXMsIHByb3BlcnRpZXMpO1xuICB2YXIgdGltaW5ncyA9IGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKTtcbiAgdmFyIGlkID0gaW5zdGFuY2VJRDtcbiAgaW5zdGFuY2VJRCsrO1xuICByZXR1cm4gbWVyZ2VPYmplY3RzKGluc3RhbmNlU2V0dGluZ3MsIHtcbiAgICBpZDogaWQsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGFuaW1hdGFibGVzOiBhbmltYXRhYmxlcyxcbiAgICBhbmltYXRpb25zOiBhbmltYXRpb25zLFxuICAgIGR1cmF0aW9uOiB0aW1pbmdzLmR1cmF0aW9uLFxuICAgIGRlbGF5OiB0aW1pbmdzLmRlbGF5LFxuICAgIGVuZERlbGF5OiB0aW1pbmdzLmVuZERlbGF5XG4gIH0pO1xufVxuXG4vLyBDb3JlXG5cbnZhciBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcbnZhciBwYXVzZWRJbnN0YW5jZXMgPSBbXTtcbnZhciByYWY7XG5cbnZhciBlbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBwbGF5KCkgeyBcbiAgICByYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RlcCh0KSB7XG4gICAgdmFyIGFjdGl2ZUluc3RhbmNlc0xlbmd0aCA9IGFjdGl2ZUluc3RhbmNlcy5sZW5ndGg7XG4gICAgaWYgKGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgICAgICBpZiAoIWFjdGl2ZUluc3RhbmNlLnBhdXNlZCkge1xuICAgICAgICAgIGFjdGl2ZUluc3RhbmNlLnRpY2sodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZihhY3RpdmVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGluc3RhbmNlSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpbnN0YW5jZUluZGV4LCAxKTtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlc0xlbmd0aCA9IGFjdGl2ZUluc3RhbmNlcy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFmID0gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBsYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgYWN0aXZlSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGlucykgeyByZXR1cm4gaW5zLnBhdXNlKCk7IH0pO1xuICAgIHBhdXNlZEluc3RhbmNlcyA9IGFjdGl2ZUluc3RhbmNlcy5zbGljZSgwKTtcbiAgICBhbmltZS5ydW5uaW5nID0gYWN0aXZlSW5zdGFuY2VzID0gW107XG4gIH0gZWxzZSB7XG4gICAgcGF1c2VkSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGlucykgeyByZXR1cm4gaW5zLnBsYXkoKTsgfSk7XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xufVxuXG4vLyBQdWJsaWMgSW5zdGFuY2VcblxuZnVuY3Rpb24gYW5pbWUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuXG4gIHZhciBzdGFydFRpbWUgPSAwLCBsYXN0VGltZSA9IDAsIG5vdyA9IDA7XG4gIHZhciBjaGlsZHJlbiwgY2hpbGRyZW5MZW5ndGggPSAwO1xuICB2YXIgcmVzb2x2ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFrZVByb21pc2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlICYmIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSA9IF9yZXNvbHZlOyB9KTtcbiAgICBpbnN0YW5jZS5maW5pc2hlZCA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpO1xuICB2YXIgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICBpbnN0YW5jZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24gIT09ICdub3JtYWwnID8gJ25vcm1hbCcgOiAncmV2ZXJzZSc7XG4gICAgfVxuICAgIGluc3RhbmNlLnJldmVyc2VkID0gIWluc3RhbmNlLnJldmVyc2VkO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5yZXZlcnNlZCA9IGluc3RhbmNlLnJldmVyc2VkOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdFRpbWUodGltZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWUoKSB7XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBsYXN0VGltZSA9IGFkanVzdFRpbWUoaW5zdGFuY2UuY3VycmVudFRpbWUpICogKDEgLyBhbmltZS5zcGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVrQ2hpbGQodGltZSwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHsgY2hpbGQuc2Vlayh0aW1lIC0gY2hpbGQudGltZWxpbmVPZmZzZXQpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jSW5zdGFuY2VDaGlsZHJlbih0aW1lKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baV0pOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoaWxkcmVuTGVuZ3RoOyBpJDEtLTspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2kkMV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBhbmltYXRpb25zTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBhbmltYXRpb25zTGVuZ3RoKSB7XG4gICAgICB2YXIgYW5pbSA9IGFuaW1hdGlvbnNbaV07XG4gICAgICB2YXIgYW5pbWF0YWJsZSA9IGFuaW0uYW5pbWF0YWJsZTtcbiAgICAgIHZhciB0d2VlbnMgPSBhbmltLnR3ZWVucztcbiAgICAgIHZhciB0d2Vlbkxlbmd0aCA9IHR3ZWVucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW3R3ZWVuTGVuZ3RoXTtcbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGtleWZyYW1lcyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHR3ZWVuXG4gICAgICBpZiAodHdlZW5MZW5ndGgpIHsgdHdlZW4gPSBmaWx0ZXJBcnJheSh0d2VlbnMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaW5zVGltZSA8IHQuZW5kKTsgfSlbMF0gfHwgdHdlZW47IH1cbiAgICAgIHZhciBlbGFwc2VkID0gbWluTWF4KGluc1RpbWUgLSB0d2Vlbi5zdGFydCAtIHR3ZWVuLmRlbGF5LCAwLCB0d2Vlbi5kdXJhdGlvbikgLyB0d2Vlbi5kdXJhdGlvbjtcbiAgICAgIHZhciBlYXNlZCA9IGlzTmFOKGVsYXBzZWQpID8gMSA6IHR3ZWVuLmVhc2luZyhlbGFwc2VkKTtcbiAgICAgIHZhciBzdHJpbmdzID0gdHdlZW4udG8uc3RyaW5ncztcbiAgICAgIHZhciByb3VuZCA9IHR3ZWVuLnJvdW5kO1xuICAgICAgdmFyIG51bWJlcnMgPSBbXTtcbiAgICAgIHZhciB0b051bWJlcnNMZW5ndGggPSB0d2Vlbi50by5udW1iZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9ncmVzcyA9ICh2b2lkIDApO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0b051bWJlcnNMZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIHRvTnVtYmVyID0gdHdlZW4udG8ubnVtYmVyc1tuXTtcbiAgICAgICAgdmFyIGZyb21OdW1iZXIgPSB0d2Vlbi5mcm9tLm51bWJlcnNbbl0gfHwgMDtcbiAgICAgICAgaWYgKCF0d2Vlbi5pc1BhdGgpIHtcbiAgICAgICAgICB2YWx1ZSA9IGZyb21OdW1iZXIgKyAoZWFzZWQgKiAodG9OdW1iZXIgLSBmcm9tTnVtYmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRQYXRoUHJvZ3Jlc3ModHdlZW4udmFsdWUsIGVhc2VkICogdG9OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgIGlmICghKHR3ZWVuLmlzQ29sb3IgJiYgbiA+IDIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiByb3VuZCkgLyByb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE1hbnVhbCBBcnJheS5yZWR1Y2UgZm9yIGJldHRlciBwZXJmb3JtYW5jZXNcbiAgICAgIHZhciBzdHJpbmdzTGVuZ3RoID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICBpZiAoIXN0cmluZ3NMZW5ndGgpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBudW1iZXJzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBzdHJpbmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN0cmluZ3NMZW5ndGg7IHMrKykge1xuICAgICAgICAgIHZhciBhID0gc3RyaW5nc1tzXTtcbiAgICAgICAgICB2YXIgYiA9IHN0cmluZ3NbcyArIDFdO1xuICAgICAgICAgIHZhciBuJDEgPSBudW1iZXJzW3NdO1xuICAgICAgICAgIGlmICghaXNOYU4obiQxKSkge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArICcgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW0udHlwZV0oYW5pbWF0YWJsZS50YXJnZXQsIGFuaW0ucHJvcGVydHksIHByb2dyZXNzLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMpO1xuICAgICAgYW5pbS5jdXJyZW50VmFsdWUgPSBwcm9ncmVzcztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYWxsYmFjayhjYikge1xuICAgIGlmIChpbnN0YW5jZVtjYl0gJiYgIWluc3RhbmNlLnBhc3NUaHJvdWdoKSB7IGluc3RhbmNlW2NiXShpbnN0YW5jZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50SXRlcmF0aW9uKCkge1xuICAgIGlmIChpbnN0YW5jZS5yZW1haW5pbmcgJiYgaW5zdGFuY2UucmVtYWluaW5nICE9PSB0cnVlKSB7XG4gICAgICBpbnN0YW5jZS5yZW1haW5pbmctLTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbnN0YW5jZVByb2dyZXNzKGVuZ2luZVRpbWUpIHtcbiAgICB2YXIgaW5zRHVyYXRpb24gPSBpbnN0YW5jZS5kdXJhdGlvbjtcbiAgICB2YXIgaW5zRGVsYXkgPSBpbnN0YW5jZS5kZWxheTtcbiAgICB2YXIgaW5zRW5kRGVsYXkgPSBpbnNEdXJhdGlvbiAtIGluc3RhbmNlLmVuZERlbGF5O1xuICAgIHZhciBpbnNUaW1lID0gYWRqdXN0VGltZShlbmdpbmVUaW1lKTtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IG1pbk1heCgoaW5zVGltZSAvIGluc0R1cmF0aW9uKSAqIDEwMCwgMCwgMTAwKTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBpbnNUaW1lIDwgaW5zdGFuY2UuY3VycmVudFRpbWU7XG4gICAgaWYgKGNoaWxkcmVuKSB7IHN5bmNJbnN0YW5jZUNoaWxkcmVuKGluc1RpbWUpOyB9XG4gICAgaWYgKCFpbnN0YW5jZS5iZWdhbiAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIGluc3RhbmNlLmJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdiZWdpbicpO1xuICAgIH1cbiAgICBpZiAoIWluc3RhbmNlLmxvb3BCZWdhbiAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIGluc3RhbmNlLmxvb3BCZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnbG9vcEJlZ2luJyk7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lIDw9IGluc0RlbGF5ICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lICE9PSAwKSB7XG4gICAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoMCk7XG4gICAgfVxuICAgIGlmICgoaW5zVGltZSA+PSBpbnNFbmREZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gaW5zRHVyYXRpb24pIHx8ICFpbnNEdXJhdGlvbikge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc0R1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGluc1RpbWUgPiBpbnNEZWxheSAmJiBpbnNUaW1lIDwgaW5zRW5kRGVsYXkpIHtcbiAgICAgIGlmICghaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUJlZ2luJyk7XG4gICAgICB9XG4gICAgICBzZXRDYWxsYmFjaygnY2hhbmdlJyk7XG4gICAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jaGFuZ2VCZWdhbikge1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VCZWdhbiA9IGZhbHNlO1xuICAgICAgICBzZXRDYWxsYmFjaygnY2hhbmdlQ29tcGxldGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSBtaW5NYXgoaW5zVGltZSwgMCwgaW5zRHVyYXRpb24pO1xuICAgIGlmIChpbnN0YW5jZS5iZWdhbikgeyBzZXRDYWxsYmFjaygndXBkYXRlJyk7IH1cbiAgICBpZiAoZW5naW5lVGltZSA+PSBpbnNEdXJhdGlvbikge1xuICAgICAgbGFzdFRpbWUgPSAwO1xuICAgICAgY291bnRJdGVyYXRpb24oKTtcbiAgICAgIGlmICghaW5zdGFuY2UucmVtYWluaW5nKSB7XG4gICAgICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIGlmICghaW5zdGFuY2UuY29tcGxldGVkKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnbG9vcENvbXBsZXRlJyk7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2NvbXBsZXRlJyk7XG4gICAgICAgICAgaWYgKCFpbnN0YW5jZS5wYXNzVGhyb3VnaCAmJiAnUHJvbWlzZScgaW4gd2luZG93KSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUaW1lID0gbm93O1xuICAgICAgICBzZXRDYWxsYmFjaygnbG9vcENvbXBsZXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmxvb3BCZWdhbiA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJykge1xuICAgICAgICAgIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnN0YW5jZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaW5zdGFuY2UucGFzc1Rocm91Z2ggPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IDA7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSAwO1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgaW5zdGFuY2UuYmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VCZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnJldmVyc2VQbGF5YmFjayA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnJldmVyc2VkID0gZGlyZWN0aW9uID09PSAncmV2ZXJzZSc7XG4gICAgaW5zdGFuY2UucmVtYWluaW5nID0gaW5zdGFuY2UubG9vcDtcbiAgICBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICAgIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbkxlbmd0aDsgaS0tOykgeyBpbnN0YW5jZS5jaGlsZHJlbltpXS5yZXNldCgpOyB9XG4gICAgaWYgKGluc3RhbmNlLnJldmVyc2VkICYmIGluc3RhbmNlLmxvb3AgIT09IHRydWUgfHwgKGRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScgJiYgaW5zdGFuY2UubG9vcCA9PT0gMSkpIHsgaW5zdGFuY2UucmVtYWluaW5nKys7IH1cbiAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zdGFuY2UucmV2ZXJzZWQgPyBpbnN0YW5jZS5kdXJhdGlvbiA6IDApO1xuICB9O1xuXG4gIC8vIFNldCBWYWx1ZSBoZWxwZXJcblxuICBpbnN0YW5jZS5zZXQgPSBmdW5jdGlvbih0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBpbnN0YW5jZS50aWNrID0gZnVuY3Rpb24odCkge1xuICAgIG5vdyA9IHQ7XG4gICAgaWYgKCFzdGFydFRpbWUpIHsgc3RhcnRUaW1lID0gbm93OyB9XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcygobm93ICsgKGxhc3RUaW1lIC0gc3RhcnRUaW1lKSkgKiBhbmltZS5zcGVlZCk7XG4gIH07XG5cbiAgaW5zdGFuY2Uuc2VlayA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKGFkanVzdFRpbWUodGltZSkpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICByZXNldFRpbWUoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5wYXVzZWQpIHsgcmV0dXJuOyB9XG4gICAgaWYgKGluc3RhbmNlLmNvbXBsZXRlZCkgeyBpbnN0YW5jZS5yZXNldCgpOyB9XG4gICAgaW5zdGFuY2UucGF1c2VkID0gZmFsc2U7XG4gICAgYWN0aXZlSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgIHJlc2V0VGltZSgpO1xuICAgIGlmICghcmFmKSB7IGVuZ2luZSgpOyB9XG4gIH07XG5cbiAgaW5zdGFuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnJlc2V0KCk7XG4gICAgaW5zdGFuY2UucGxheSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc2V0KCk7XG5cbiAgaWYgKGluc3RhbmNlLmF1dG9wbGF5KSB7IGluc3RhbmNlLnBsYXkoKTsgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcblxufVxuXG4vLyBSZW1vdmUgdGFyZ2V0cyBmcm9tIGFuaW1hdGlvblxuXG5mdW5jdGlvbiByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKSB7XG4gIGZvciAodmFyIGEgPSBhbmltYXRpb25zLmxlbmd0aDsgYS0tOykge1xuICAgIGlmIChhcnJheUNvbnRhaW5zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9uc1thXS5hbmltYXRhYmxlLnRhcmdldCkpIHtcbiAgICAgIGFuaW1hdGlvbnMuc3BsaWNlKGEsIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgZm9yICh2YXIgaSA9IGFjdGl2ZUluc3RhbmNlcy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZXNbaV07XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpO1xuICAgIGZvciAodmFyIGMgPSBjaGlsZHJlbi5sZW5ndGg7IGMtLTspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2NdO1xuICAgICAgdmFyIGNoaWxkQW5pbWF0aW9ucyA9IGNoaWxkLmFuaW1hdGlvbnM7XG4gICAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBjaGlsZEFuaW1hdGlvbnMpO1xuICAgICAgaWYgKCFjaGlsZEFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHsgY2hpbGRyZW4uc3BsaWNlKGMsIDEpOyB9XG4gICAgfVxuICAgIGlmICghYW5pbWF0aW9ucy5sZW5ndGggJiYgIWNoaWxkcmVuLmxlbmd0aCkgeyBpbnN0YW5jZS5wYXVzZSgpOyB9XG4gIH1cbn1cblxuLy8gU3RhZ2dlciBoZWxwZXJzXG5cbmZ1bmN0aW9uIHN0YWdnZXIodmFsLCBwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciBkaXJlY3Rpb24gPSBwYXJhbXMuZGlyZWN0aW9uIHx8ICdub3JtYWwnO1xuICB2YXIgZWFzaW5nID0gcGFyYW1zLmVhc2luZyA/IHBhcnNlRWFzaW5ncyhwYXJhbXMuZWFzaW5nKSA6IG51bGw7XG4gIHZhciBncmlkID0gcGFyYW1zLmdyaWQ7XG4gIHZhciBheGlzID0gcGFyYW1zLmF4aXM7XG4gIHZhciBmcm9tSW5kZXggPSBwYXJhbXMuZnJvbSB8fCAwO1xuICB2YXIgZnJvbUZpcnN0ID0gZnJvbUluZGV4ID09PSAnZmlyc3QnO1xuICB2YXIgZnJvbUNlbnRlciA9IGZyb21JbmRleCA9PT0gJ2NlbnRlcic7XG4gIHZhciBmcm9tTGFzdCA9IGZyb21JbmRleCA9PT0gJ2xhc3QnO1xuICB2YXIgaXNSYW5nZSA9IGlzLmFycih2YWwpO1xuICB2YXIgdmFsMSA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFswXSkgOiBwYXJzZUZsb2F0KHZhbCk7XG4gIHZhciB2YWwyID0gaXNSYW5nZSA/IHBhcnNlRmxvYXQodmFsWzFdKSA6IDA7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChpc1JhbmdlID8gdmFsWzFdIDogdmFsKSB8fCAwO1xuICB2YXIgc3RhcnQgPSBwYXJhbXMuc3RhcnQgfHwgMCArIChpc1JhbmdlID8gdmFsMSA6IDApO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBtYXhWYWx1ZSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwsIGksIHQpIHtcbiAgICBpZiAoZnJvbUZpcnN0KSB7IGZyb21JbmRleCA9IDA7IH1cbiAgICBpZiAoZnJvbUNlbnRlcikgeyBmcm9tSW5kZXggPSAodCAtIDEpIC8gMjsgfVxuICAgIGlmIChmcm9tTGFzdCkgeyBmcm9tSW5kZXggPSB0IC0gMTsgfVxuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHQ7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKCFncmlkKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goTWF0aC5hYnMoZnJvbUluZGV4IC0gaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJvbVggPSAhZnJvbUNlbnRlciA/IGZyb21JbmRleCVncmlkWzBdIDogKGdyaWRbMF0tMSkvMjtcbiAgICAgICAgICB2YXIgZnJvbVkgPSAhZnJvbUNlbnRlciA/IE1hdGguZmxvb3IoZnJvbUluZGV4L2dyaWRbMF0pIDogKGdyaWRbMV0tMSkvMjtcbiAgICAgICAgICB2YXIgdG9YID0gaW5kZXglZ3JpZFswXTtcbiAgICAgICAgICB2YXIgdG9ZID0gTWF0aC5mbG9vcihpbmRleC9ncmlkWzBdKTtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VYID0gZnJvbVggLSB0b1g7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWSA9IGZyb21ZIC0gdG9ZO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE1hdGguc3FydChkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVkpO1xuICAgICAgICAgIGlmIChheGlzID09PSAneCcpIHsgdmFsdWUgPSAtZGlzdGFuY2VYOyB9XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd5JykgeyB2YWx1ZSA9IC1kaXN0YW5jZVk7IH1cbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGVhc2luZykgeyB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGVhc2luZyh2YWwgLyBtYXhWYWx1ZSkgKiBtYXhWYWx1ZTsgfSk7IH1cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyZXZlcnNlJykgeyB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGF4aXMgPyAodmFsIDwgMCkgPyB2YWwgKiAtMSA6IC12YWwgOiBNYXRoLmFicyhtYXhWYWx1ZSAtIHZhbCk7IH0pOyB9XG4gICAgfVxuICAgIHZhciBzcGFjaW5nID0gaXNSYW5nZSA/ICh2YWwyIC0gdmFsMSkgLyBtYXhWYWx1ZSA6IHZhbDE7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKHNwYWNpbmcgKiAoTWF0aC5yb3VuZCh2YWx1ZXNbaV0gKiAxMDApIC8gMTAwKSkgKyB1bml0O1xuICB9XG59XG5cbi8vIFRpbWVsaW5lXG5cbmZ1bmN0aW9uIHRpbWVsaW5lKHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cbiAgdmFyIHRsID0gYW5pbWUocGFyYW1zKTtcbiAgdGwuZHVyYXRpb24gPSAwO1xuICB0bC5hZGQgPSBmdW5jdGlvbihpbnN0YW5jZVBhcmFtcywgdGltZWxpbmVPZmZzZXQpIHtcbiAgICB2YXIgdGxJbmRleCA9IGFjdGl2ZUluc3RhbmNlcy5pbmRleE9mKHRsKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0bC5jaGlsZHJlbjtcbiAgICBpZiAodGxJbmRleCA+IC0xKSB7IGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UodGxJbmRleCwgMSk7IH1cbiAgICBmdW5jdGlvbiBwYXNzVGhyb3VnaChpbnMpIHsgaW5zLnBhc3NUaHJvdWdoID0gdHJ1ZTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsgcGFzc1Rocm91Z2goY2hpbGRyZW5baV0pOyB9XG4gICAgdmFyIGluc1BhcmFtcyA9IG1lcmdlT2JqZWN0cyhpbnN0YW5jZVBhcmFtcywgcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRUd2VlblNldHRpbmdzLCBwYXJhbXMpKTtcbiAgICBpbnNQYXJhbXMudGFyZ2V0cyA9IGluc1BhcmFtcy50YXJnZXRzIHx8IHBhcmFtcy50YXJnZXRzO1xuICAgIHZhciB0bER1cmF0aW9uID0gdGwuZHVyYXRpb247XG4gICAgaW5zUGFyYW1zLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgaW5zUGFyYW1zLmRpcmVjdGlvbiA9IHRsLmRpcmVjdGlvbjtcbiAgICBpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQgPSBpcy51bmQodGltZWxpbmVPZmZzZXQpID8gdGxEdXJhdGlvbiA6IGdldFJlbGF0aXZlVmFsdWUodGltZWxpbmVPZmZzZXQsIHRsRHVyYXRpb24pO1xuICAgIHBhc3NUaHJvdWdoKHRsKTtcbiAgICB0bC5zZWVrKGluc1BhcmFtcy50aW1lbGluZU9mZnNldCk7XG4gICAgdmFyIGlucyA9IGFuaW1lKGluc1BhcmFtcyk7XG4gICAgcGFzc1Rocm91Z2goaW5zKTtcbiAgICBjaGlsZHJlbi5wdXNoKGlucyk7XG4gICAgdmFyIHRpbWluZ3MgPSBnZXRJbnN0YW5jZVRpbWluZ3MoY2hpbGRyZW4sIHBhcmFtcyk7XG4gICAgdGwuZGVsYXkgPSB0aW1pbmdzLmRlbGF5O1xuICAgIHRsLmVuZERlbGF5ID0gdGltaW5ncy5lbmREZWxheTtcbiAgICB0bC5kdXJhdGlvbiA9IHRpbWluZ3MuZHVyYXRpb247XG4gICAgdGwuc2VlaygwKTtcbiAgICB0bC5yZXNldCgpO1xuICAgIGlmICh0bC5hdXRvcGxheSkgeyB0bC5wbGF5KCk7IH1cbiAgICByZXR1cm4gdGw7XG4gIH07XG4gIHJldHVybiB0bDtcbn1cblxuYW5pbWUudmVyc2lvbiA9ICczLjEuMCc7XG5hbmltZS5zcGVlZCA9IDE7XG5hbmltZS5ydW5uaW5nID0gYWN0aXZlSW5zdGFuY2VzO1xuYW5pbWUucmVtb3ZlID0gcmVtb3ZlVGFyZ2V0cztcbmFuaW1lLmdldCA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWU7XG5hbmltZS5zZXQgPSBzZXRUYXJnZXRzVmFsdWU7XG5hbmltZS5jb252ZXJ0UHggPSBjb252ZXJ0UHhUb1VuaXQ7XG5hbmltZS5wYXRoID0gZ2V0UGF0aDtcbmFuaW1lLnNldERhc2hvZmZzZXQgPSBzZXREYXNob2Zmc2V0O1xuYW5pbWUuc3RhZ2dlciA9IHN0YWdnZXI7XG5hbmltZS50aW1lbGluZSA9IHRpbWVsaW5lO1xuYW5pbWUuZWFzaW5nID0gcGFyc2VFYXNpbmdzO1xuYW5pbWUucGVubmVyID0gcGVubmVyO1xuYW5pbWUucmFuZG9tID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuaW1lO1xuIiwiLyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcbiIsImlmICh3aW5kb3cuTm9kZUxpc3QgJiYgIU5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIHRoaXNBcmcgPSB0aGlzQXJnIHx8IHdpbmRvdztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzW2ldLCBpLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbiJdfQ=="}